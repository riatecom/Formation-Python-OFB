---
title: "Formation Python pour g√©omaticiens üêçüåè"
author: "Matthieu Viry"
subtitle: "11 D√©cembre 2023"
format:
  revealjs:
    embed-resources: false
    slide-number: true
    show-slide-number: all
    chalkboard: true
    logo: images/logos-footer.png
jupyter: python3
title-slide-attributes:
  data-background-image: images/logos-footer.png
  data-background-size: 42%
  data-background-position: 50% 90%
css: ['static/style.css']
prefer-html: true
bibliography: references.bib
csl: "universite-de-montreal-apa.csl"
lang: fr
---

## Programme de la demi-journ√©e

<br />

:::{.medium}

- **Partie 1** : Introduction √† Python
- **Partie 2** : Mise en pratique / Exercices
- **Partie 3** : Python et QGIS
- **Partie 4** : Mise en pratique / Exercices
- **Conclusion**

**Objectifs** : D√©couvrir le langage de programmation Python et son √©cosyst√®me, et apprendre √† l'utiliser pour r√©aliser des traitements g√©omatiques dans QGIS.

Rappels des instructions pour installer l'environnement Python : [Installation d'un environnement Python pour Windows avec Anaconda et VSCodium](installation.html)

:::

# Partie 1 - Introduction √† Python

## Pourquoi programmer ?

- **Automatiser** des t√¢ches r√©p√©titives
- **Prendre le contr√¥le** des analyses et des traitements que vous r√©alisez

## Historique et pr√©sentation sur le papier...

<img src="images/logo-python.png" style="position: absolute;top: 40px;right: 10px;width: 105px !important;height: auto;" />

<br /><br />

- Langage cr√©√© √† la toute fin des ann√©es 80 - premi√®re version publique sortie en 1991.

- **Libre** (r√©git par la *Python Software Foundation License*, √©quivalent √† BSD)

- Langage **polyvalent**, **interpr√©t√©**, **multi-paradigme** (imp√©ratif, fonctionnel, OO, ..)

- **Typage dynamique fort** (et *duck typing*)

- Toujours en d√©veloppement actif (derni√®re version stable en octobre 2023)

::: {.notes}


En 1989 aux Pays-Bas, Guido van Rossum invente le langage de programmation Python.
C‚Äôest un fan de la s√©rie t√©l√©vis√©e Monty Python‚Äôs Flying Circus, donc pour rendre un hommage √† la s√©rie il donne le nom Python.
Ce n‚Äôest qu‚Äôen 1991 que la premi√®re version de ce langage a √©t√© publi√©e.

C‚Äôest la Python Software Foundation qui se charge de d√©velopper Python et de faire vivre la communaut√© de d√©veloppeurs et utilisateurs.


- Il est multiplateforme : fonctionne sur des nombreux syst√®mes d‚Äôexploitation ;
- C'est un logiciel libre
- C‚Äôest un langage interpr√©t√© : le script python est directement ex√©cut√©, il n‚Äôa pas besoin d‚Äô√™tre compil√© avant d‚Äô√™tre ex√©cut√© ;
- C‚Äôest un langage orient√© objet : on peut cr√©er des programmes qui imite le comportement du monde r√©el ;
- Enfin, il est notamment utilis√© en bio-informatique, et plus couramment en analyse de donn√©es.


Sur le site web, la description en une phrase du projet est "Python is a programming language that lets you work quickly and integrate systems more effectively"

Pour sa part le projet **R** na√Æt en 1993 comme un projet de recherche de Ross Ihaka et Robert Gentleman √† l'universit√© d'Auckland.

- C'est une impl√©mentation du langage **S** (d√©velopp√© au milieu des ann√©es 70 dans les laboratoires Bell)

- **Libre** (licence *GNU GPL*)

- Langage **interpr√©t√©**, **multi-paradigme** (imp√©ratif, fonctionnel, OO, ..)

- **Typage dynamique**

- Toujours en d√©veloppement actif (derni√®re version en avril 2023)


Sur le site web, le titre est "The R Project for Statistical Computing" et la description en une phrase du projet est : "R is a free software environment for statistical computing and graphics".

:::

## Python

:::{.center}

![](images/xkcd-python.png)

:::
   
## Python / R

<br>

:::: {.columns}

::: {.column .medium width="50%"}

### Python

- *General-purpose programming language*

- *"Jack of all trades, master of none"* ?

- Utilis√© par Google, Facebook, Spotify, IBM, etc.

:::

::: {.column .medium width="50%"}


### R

- *For statistical computing and graphics*

- *"By statisticians, for statisticians"*

- Utilis√© par Google, Facebook, Microsoft, etc.

:::

::::

- Mais la question se pose car Python est de plus en plus comp√©tent pour l'analyse de donn√©es...

# Pr√©sentation de l'√©cosyst√®me

## Impl√©mentation de r√©f√©rence et distributions

- Une impl√©mentation de r√©f√©rence du langage [**Python**](https://www.python.org/) : [**CPython**](https://github.com/python/cpython)
  (mais d'autres impl√©mentations : Jython, IronPython, PyPy, etc.)

- Plusieurs *distributions* de Python (principalement [**Anaconda**](https://anaconda.org/), une distribution des langages de programmation Python et R d√©di√©e √† la science des donn√©es et √† l'apprentissage automatique)

<div class="center">
<img src="images/logo-anaconda.png" />
<p class="small">Source: <a href="https://anaconda.org">anaconda.org</a></p>
</div>

::: {.notes}

- CPython est l'impl√©mentation de r√©f√©rence de Python. C'est la version que la plupart des gens utilisent, notamment parce qu'elle est la plus facile √† installer et √† utiliser. Il est √©crit en langage C et est maintenu par la Python Software Foundation.

- Jython est une impl√©mentation de Python √©crite en Java. Il permet aux d√©veloppeurs d'√©crire des programmes Python qui peuvent √™tre ex√©cut√©s sur n'importe quelle machine virtuelle Java (JVM). Cela le rend particuli√®rement utile pour les d√©veloppeurs qui travaillent dans un environnement Java.

- IronPython est une impl√©mentation de Python √©crite en C# et destin√©e √† √™tre utilis√©e dans l'environnement .NET. Il permet aux d√©veloppeurs d'√©crire des programmes Python qui peuvent √™tre ex√©cut√©s sur la plate-forme .NET. Il est particuli√®rement utile pour les d√©veloppeurs qui travaillent dans un environnement .NET.

- PyPy est une impl√©mentation alternative de Python qui est destin√©e √† √™tre plus rapide que CPython. Il est √©crit en langage RPython et utilise une technique d'optimisation appel√©e compilation √† la vol√©e pour acc√©l√©rer l'ex√©cution des programmes.


Anaconda est une distribution gratuite et open source de Python et R, qui a √©t√© d√©velopp√©e pour simplifier le processus
d'installation et de gestion des packages, ainsi que le processus
de configuration et de gestion des environnements de d√©veloppement scientifique de donn√©es.

Il a √©t√© cr√©√© par Continuum Analytics, une entreprise qui a depuis √©t√© acquise par Anaconda, Inc.

Anaconda est livr√© avec une gamme compl√®te de biblioth√®ques scientifiques et de packages pr√©install√©s,
tels que NumPy, pandas, Matplotlib, SciPy, scikit-learn, TensorFlow et Jupyter Notebook, pour n'en citer que quelques-uns.
Il est √©galement facile √† √©tendre avec des packages tiers, en utilisant le gestionnaire de packages conda, qui permet de t√©l√©charger et d'installer des packages √† partir de sources externes.

L'un des avantages les plus importants d'Anaconda est son syst√®me de gestion d'environnement,
qui permet de cr√©er des environnements Python isol√©s pour diff√©rents projets.

:::

## Environnements de d√©veloppement

- Plusieurs IDE appr√©ci√©s par les utilisateurs de Python : [**Spyder**](https://www.spyder-ide.org/) (IDE "scientifique", interface comparable √† RStudio),
  [**PyCharm**](https://www.jetbrains.com/pycharm/) (logiciel propri√©taire, plut√¥t pour d√©velopper des biblioth√®ques), [**Jupyter Lab**](https://jupyter.org/)
  et plus r√©cemment [**Visual Studio Code**](https://code.visualstudio.com/) (VSCode, VSCodium).


<img src="images/spyder.png" style="float:left; width: 46%;" />

<img src="https://www.jetbrains.com/pycharm/img/screenshots/complexLook@2x.jpg" style="float:right; width: 46%;"/>

## *Batteries included* üîã

:::{.medium}

Le langage de programmation Python a une biblioth√®que standard tr√®s compl√®te, comportant de nombreux modules qui permettent de r√©aliser des t√¢ches courantes sans avoir √† r√©inventer la roue.

:::

:::{.small}

[Modules de la biblioth√®que standard](https://docs.python.org/3/library/index.html) :

- `math` (fonctions math√©matiques de base)
- `statistics` (statistiques descriptives)
- `random` (g√©n√©ration de nombres al√©atoires)
- `datetime` (gestion des dates et heures)
- `os` (fonctions d'interaction avec le syst√®me d'exploitation)
- `sys` (fonctions et variables d'interaction avec l'interpr√©teur Python)
- `re` (expressions r√©guli√®res)
- `csv` (lecture et √©criture de fichiers CSV)
- `json` (lecture et √©criture de fichiers JSON)
- `sqlite3` (interface avec la base de donn√©es SQLite)
- etc.

:::

## Modules additionnels (biblioth√®ques)


## Modules additionnels (biblioth√®ques)

<br />
<center>

![](images/python-stack.png)

</center>

## Documentation

::: {.small}
Un point fort de Python est sa documentation officielle, qui contient tout le n√©cessaire pour utiliser le langage de mani√®re proactive
(tutoriel, r√©f√©rence de l'ensemble des fonctions et des objets de tous les modules de la biblioth√®que standard, etc.)
et qui est mise √† disposition dans plusieurs langues (Anglais, Fran√ßais, Espagnol, Cor√©en, Japonais, Chinois, etc.).
:::

<center>

![](images/python-documentation.png)

</center>


## Documentation / Modules additionnels


Il n'existe toutefois pas un seul standard pour consulter la documentation des diff√©rents modules additionnels Python
(cf. [Documentation Matplotlib](https://matplotlib.org/stable/api/index), [Documentation pandas](https://pandas.pydata.org/docs/reference/index.html#api)).

<img src="images/doc-geopandas.png" style="width: 40%; position: absolute; border: solid 1px black; left: 10px;" />

<img src="images/doc-matplotlib.png" style="width: 40%; position: absolute; border: solid 1px black; bottom: -60px; left: 29%;" />

<img src="images/doc-samgeo.png" style="width: 40%; position: absolute; border: solid 1px black; right: 10px;" />

# En terme de syntaxe √ßa donne quoi ?

## Premier pas avec la syntaxe Python

<br>

```{python}
#| error: true
#| echo: true
#| message: true
#| cache: true
import math # On importe le module math
# Et deux fonctions du module statistics
from statistics import mean, stdev

# D√©finition d'une fonction
def cv(x):
    moy = mean(x)
    s = stdev(x)
    result = s / moy
    # Retourne le r√©sultat
    return result 

# La fonction est appel√©e avec une liste de valeurs,
# et le r√©sultat est stock√© dans une variable 
res = cv([5, 6, 3, 8, 9, 12])

# Affichage du r√©sultat
print(res)
```

## Python et l'indentation du code...

<br>

```{python}
#| error: true
#| echo: true
#| message: true
#| cache: true
my_list = [1, 2, 3]

for item in my_list:
    if item % 2 == 0:
        print('even')
    else:
    print('odd')
```

## Python et l'indentation du code...

<br>

```{python}
#| error: true
#| echo: true
#| message: true
#| cache: true
my_list = [1, 2, 3]

for item in my_list:
    if item % 2 == 0:
        print('even')
    else:
        print('odd')
```

## Python et l'indentation du code...

<br>

- Respecter les r√®gles d‚Äôindentations est *obligatoire* en Python.

- Ce n'est pas une *contrainte* lors d'une session de travail car les IDE guident la position du curseur.

- Cette indentation a un r√¥le direct sur le contr√¥le du flux d'ex√©cution.

- Elle permet notamment d'√©viter l'utilisation d'accolades (*curly brackets*) pour d√©limiter les blocs et de point-virgules pour d√©limiter les instructions.


## Python et l'indentation du code...

<br>

Le code qui suit est volontairement incorrect mais ne g√©n√®re pas d'erreur lors de l'ex√©cution :

```{python}
#| echo: true
li1 = [1, 2, 3, 4, 5, 6]
li2 = [4, 20, 31, 87, 123, 621]

# Additionnons les deux listes, √©l√©ments par √©l√©ments,
# et stockons chaque r√©sultat dans une nouvelle liste
result = []

for item1, item2 in zip(li1, li2):
    new_item = item1 + item2
result.append(new_item)

print(result)
```

## Python et l'indentation du code...

<br>

Une fois l'indentation corrig√©e...

```{python}
#| echo: true
li1 = [1, 2, 3, 4, 5, 6]
li2 = [4, 20, 31, 87, 123, 621]

# Additionnons les deux listes, √©l√©ments par √©l√©ments,
# et stockons chaque r√©sultat dans une nouvelle liste
result = []

for item1, item2 in zip(li1, li2):
    new_item = item1 + item2
    result.append(new_item)

print(result)
```

# Premi√®res commandes dans l'interpr√©teur Python

## L'interpr√©teur Python

<br>

:::{.medium}

- L'interpr√©teur Python est un programme qui lit et ex√©cute du code Python.
- Il est possible d'interagir avec l'interpr√©teur Python en utilisant un terminal (ou une console) ou en utilisant un IDE.
- L'interpr√©teur Python est lanc√© en tapant `python` dans un terminal.
- Il est possible de quitter l'interpr√©teur Python en tapant `exit()` ou en appuyant sur `Ctrl + D`.
- L'interpr√©teur Python peut √™tre utilis√© pour ex√©cuter des scripts Python (fichiers `.py`) en utilisant la commande `python mon_script.py`.

:::

## Calculs simples et variables

<br />

:::{.medium}

Une des premi√®res fonctionnalit√©s que l'on souhaite tester dans un langage de programmation est la possibilit√© d'effectuer des calculs simples.

```
>>> 1 + 2
3
>>> 3 * 4
12
```

Vous pouvez ou non utiliser des espaces autour des op√©rateurs (`+`, `-`, `*`, `/`, etc.) :

```
>>> 1+2
3
```

La double √©toile repr√©sente l'exposant.

```
>>> 2 ** 3
8
```

:::

## Calculs simples et variables

<br />

:::{.medium}

Il est possible de stocker des valeurs dans des variables :

```
>>> a = 1
>>> b = 2
>>> result = a + b
```

Le r√©sultat n'est donc plus affich√© directement dans l'interpr√©teur Python mais stock√© dans la variable `result`.
On peut ensuite afficher le contenu de la variable `result` :

```
>>> result
3
```

Ou en utilisant la fonction `print` :

```
>>> print(result)
```

:::

## Calculs simples et variables

:::{.medium}

En Python le typage est dynamique, il n'est pas n√©cessaire de d√©clarer le type d'une variable avant de l'utiliser et il est possible de changer le type d'une variable
au cours de son existence :

```
>>> a = 1
>>> type(a)
<class 'int'>
>>> a = 'Hello world!'
>>> type(a)
<class 'str'>
```

:::


# Types natifs <br />et *data structures* natives

:::{.small}
*Les structures de donn√©es sont les √©l√©ments fondamentaux autour desquels vous construisez vos programmes. Chaque structure de donn√©es fournit une mani√®re particuli√®re d'organiser les donn√©es afin d'y acc√©der efficacement.*
:::

## Types de base

Les types de base sont les types de donn√©es les plus simples disponibles dans Python. Ils sont utilis√©s pour repr√©senter des valeurs simples.

::::{.columns .medium}
:::{.column width="50%"}

- `int` (entier)

```{python}
#| echo: true
my_int = 42
```

- `float` (nombre √† virgule flottante)

```{python}
#| echo: true
my_float = 3.14
```

- `bool` (bool√©en)

```{python}
#| echo: true
my_bool = True # ou False
```

:::

:::{.column width="50%"}

- `str` (cha√Æne de caract√®res)

```{python}
#| echo: true
my_str = 'Hello world!'
```

- `NoneType` (type sp√©cial pour la valeur `None`)

```{python}
#| echo: true
my_none = None
```

:::
::::

## Structures de donn√©es

:::{.medium}

Python est livr√© avec un ensemble complet de structures de donn√©es dans sa biblioth√®que standard :


- `dict` (tableau associatif)

```{python}
#| echo: true
my_dict = { 'john': 32, 'jane': 27, 'jack': 30 }
```

- `tuple` (un conteneur immuable),

```{python}
#| echo: true
my_coordinates = (2.349014, 48.864716)
```

- `list` (tableau dynamique mutable),

```{python}
#| echo: true
my_list = [12, 34, 2, 1, 21, 4]
other_list = ['a', 12, (2.349014, 48.864716), { "foo": 42 }]
```

- `array` (tableau typ√© de base), `enum` (√©num√©ration), etc.

:::

:::{.notes}

En informatique, une structure de donn√©es est une mani√®re d'organiser les donn√©es pour les traiter plus facilement. Une structure de donn√©es est une mise en ≈ìuvre concr√®te d'un type abstrait.

Pour prendre un exemple de la vie quotidienne, on peut pr√©senter des num√©ros de t√©l√©phone par d√©partement, par nom, par profession (comme les Pages jaunes), par num√©ro t√©l√©phonique (comme les annuaires destin√©s au t√©l√©marketing), par rue et/ou une combinaison quelconque de ces classements. √Ä chaque usage correspondra une structure d'annuaire appropri√©e.

En organisant d'une certaine mani√®re les donn√©es, on permet un traitement automatique de ces derni√®res plus efficace et rapide.

Souvent (en tout cas pour les cas qui nous concernent ici) il s'agira de collections d'objets, par exemple un tableau de nombre, 
un tableau associatif (dictionnaire) permettant de faire correspondre des cl√©s (noms par ex) √† des valeurs (num√©ro de t√©l√©phone par ex), etc.

:::

## Structures de donn√©es - `list` (1)

[Les listes sont des tableaux dynamiques, elles peuvent contenir des √©l√©ments de diff√©rents types et sont mutables.]{.medium}

::::{.columns .medium}

:::{.column width="50%"}

- **Cr√©ation** :

Liste vide :

```{python}
#| echo: true
ma_liste = []
```

Ou cr√©ation d'une liste avec des √©l√©ments :

```{python}
#| echo: true
ma_liste = [12, 34, 2, 1, 21, 43]
```

<br />

- **Connaitre la taille d'une liste** :

```{python}
#| echo: true
len(ma_liste)
```

:::

:::{.column width="50%"}

- **Acc√®s aux √©l√©ments** :


```{python}
#| echo: true
ma_liste[0] # Premier √©l√©ment
```

```{python}
#| echo: true
ma_liste[-1] # Dernier √©l√©ment
```

```{python}
#| echo: true
ma_liste[1] = 42 # Modification d'un √©l√©ment
```

<br />

- **Acc√®s √† un sous-ensemble d'√©l√©ments** (*slicing*) :

```{python}
#| echo: true
my_slice = ma_liste[1:3]
my_slice
```

:::
::::

## Structures de donn√©es - `list` (2)

:::{.medium}

De nombreuses *m√©thodes* permettant de manipuler les listes.

- **Ajouter des √©l√©ments √† une liste existante** :

```{python}
#| echo: true
ma_liste.append(322)
```

<br />


- **Supprimer un √©l√©ment d'une liste** :

```{python}
#| echo: true
 # Supprime la premi√®re occurrence de l'√©l√©ment 322
ma_liste.remove(322)
```

```{python}
#| echo: true
 # Supprime l'√©l√©ment √† l'indice 0 (et le retourne)
ma_liste.pop(0)
```

Il existe √©galement des m√©thodes permettant de trier une liste (`sort`), d'ajouter un √©l√©ment √† une position pr√©cise (`insert`), etc. etc.

:::

## Structures de donn√©es - `tuple`

:::{.medium}

Puisqu'il s'agit d'un type immuable, il n'est pas possible de modifier un tuple une fois qu'il a √©t√© cr√©√© :

- **Cr√©ation** :

```{python}
#| echo: true
my_tuple = (1, 2, 3)
```

- **Acc√®s aux √©l√©ments** :

```{python}
#| echo: true
my_tuple[0] # Comme pour une liste
```

- **Pas de modification possible** :

```{python}
#| error: true
#| echo: true
my_tuple[0] = 42
```

:::


## Structures de donn√©es - `dict` (1)

:::{.medium}

Il s'agit d'un tableau associatif, les √©l√©ments sont stock√©s sous forme de cl√© / valeur. Il ne s‚Äôagit donc pas d‚Äôobjets s√©quentiels comme les listes, mais plut√¥t d‚Äôobjets dits de correspondance (*mapping objects* en anglais).

:::

::::{.columns .medium}

:::{.column width="50%"}

- **Cr√©ation** d'un dictionnaire **vide** :

```{python}
#| echo: true
my_dict = {}
```

<br />

- **Cr√©ation** d'un dictionnaire **avec des √©l√©ments** :

```{python}
#| echo: true
my_dict = { 'john': 32, 'jane': 27, 'jack': 30 }
```

<br />

- **Acc√®s aux √©l√©ments** :

```{python}
#| echo: true
my_dict['john']
```

:::

:::{.column width="50%"}

- **Modification d'un √©l√©ment** :

```{python}
#| echo: true
my_dict['john'] = 33
```

<br />

- **Ajout d'un √©l√©ment** :

```{python}
#| echo: true
my_dict['jill'] = 29
```

<br />

- **Suppression d'un √©l√©ment** :

```{python}
#| echo: true
del my_dict['john']
```

:::

::::

## Structures de donn√©es - `dict` (2)

::::{.columns .medium}

:::{.column width="50%"}

- **Acc√®s aux √©l√©ments** :

```{python}
#| echo: true
my_dict['jill']
```

<br />

*Une erreur est renvoy√©e si la cl√© n'existe pas* :

```{python}
#| error: true
#| echo: true
my_dict['johana']
```

<br />

*Il est possible de tester l'existence d'une cl√© dans un dictionnaire* :

```{python}
#| echo: true
'johana' in my_dict
```

:::

:::{.column width="50%"}

*Il est possible demander la valeur associ√©e √† une cl√© en utilisant la m√©thode `get` (et de sp√©cifier une valeur par d√©faut si la cl√© n'existe pas)* :

```{python}
#| echo: true
my_dict.get('johana')
```

```{python}
#| echo: true
my_dict.get('johana', -1)
```


<br />

- **R√©cup√©rer l'ensemble des cl√©s** :

```{python}
#| echo: true
my_dict.keys()
```

<br />

- **R√©cup√©rer l'ensemble des valeurs** :

```{python}
#| echo: true
my_dict.values()
```

:::

::::

## Structures de donn√©es - Des listes de dictionnaires ?

:::{.medium}

Il est classique de combiner des listes et des dictionnaires pour repr√©senter, par exemple, des donn√©es tabulaires :

```{python}
#| echo: true
data = [
    { 'name': 'Jill', 'age': 32,  'height': 1.65 },
    { 'name': 'Jack', 'age': 27,  'height': 1.73 },
    { 'name': 'Jane', 'age': 30,  'height': 1.80 }
]
```

:::

## Contr√¥le du flux d'ex√©cution - `if`

:::{.medium}

Le contr√¥le du flux d'ex√©cution permet de contr√¥ler l'ordre dans lequel les instructions sont ex√©cut√©es.

:::

::::{.columns .medium}

:::{.column width="50%"}

- **`if`** :

```{python}
#| echo: true
altitude = 2500

if altitude >= 2000:
    print('Haute altitude')
```

<br />

- **`if` / `else`** :

```{python}
#| echo: true
altitude = 2500

if altitude >= 2000:
    print('Haute altitude')
else:
    print('Basse altitude')
```

:::

:::{.column width="50%"}

- **`if` / `elif` / `else`** :

```{python}
#| echo: true
altitude = 2500

if altitude >= 6000:
    print('Altitude extr√™mement √©lev√©e')
elif altitude >= 4000:
    print('Tr√®s haute altitude')
elif altitude >= 2000:
    print('Haute altitude')
else:
    print('Basse altitude')
```

[Les seuils proviennent de [Wikipedia:Altitude#Adaptations_physiologiques_et_r√©ponses_physiopathologiques_du_corps_humain](https://fr.wikipedia.org/wiki/Altitude#Adaptations_physiologiques_et_r%C3%A9ponses_physiopathologiques_du_corps_humain)]{.very-small}
:::

::::

## Contr√¥le du flux d'ex√©cution - `for` (1)

:::{.medium}

La boucle `for` permet d'it√©rer sur une s√©quence (une liste, un tuple, un dictionnaire, etc.) :

:::

::::{.columns .medium}

:::{.column width="50%"}

- **`for`** :

```{python}
#| echo: true
for i in range(5):
    print(i)
```

<br />

Ici, `range()` est une fonction native qui retourne une s√©quence d'entiers :

- `range(5)` retourne la s√©quence `0, 1, 2, 3, 4`.

- `range(2, 7)` retourne la s√©quence `2, 3, 4, 5, 6`.

:::

:::{.column width="50%"}

- **`for`** sur une liste :

```{python}
#| echo: true
my_list = [12, 34, 2, 1, 3]

for item in my_list:
    print(item)
```

<br />

- **`for`** sur une liste, en utilisant `enumerate` :

```{python}
#| echo: true
for index, item in enumerate(my_list):
    print(f'Index: {index}, item: {item}')
```

:::

::::

## Contr√¥le du flux d'ex√©cution - `for` (2)

:::{.columns .medium}

:::{.column width="50%"}

- **`for`** sur un dictionnaire :

```{python}
#| echo: true
my_dict = { 'john': 32, 'jane': 27, 'jack': 30 }

for key in my_dict:
    print(key)
```

```{python}
#| echo: true
for key, value in my_dict.items():
    print(f'{key} a {value} ans')
```

:::

:::{.column width="50%"}

- **`for`** sur une cha√Æne de caract√®res :

```{python}
#| echo: true

for letter in 'Hello !':
    print(letter)
```

:::


## Contr√¥le du flux d'ex√©cution - `while`

:::{.medium}

La boucle `while` permet d'ex√©cuter un bloc d'instructions tant qu'une condition est vraie :

:::

::::{.columns .medium}

:::{.column width="50%"}

- **`while`** :

```{python}
#| echo: true
i = 0

while i < 5:
    print(i)
    i += 1
```

:::

:::{.column width="50%"}

- **`while`** avec `break` :

```{python}
#| echo: true
i = 0

while True:
    print(i)
    i += 1
    if i >= 5:
        break
```

:::

::::

## Classes

<br>

Comme Python est un langage orient√©-objet, il est √©galement possible de d√©finir des classes, permettant de facilement mod√©liser des cat√©gories d'objets...

```{python}
#| echo: true
class Point:
    def __init__(self, x, y):
      self.x = x
      self.y = y

    def distance(self, other):
      return (
        (other.x - self.x) ** 2 + (other.y - self.y) ** 2
      ) ** 0.5
```

:::{.notes}

La programmation orient√©e objet (ou programmation par objet) est un paradigme de programmation qui consiste √† mod√©liser des objets du
monde r√©el sous forme de briques logicielles appel√©es *objet*. Un objet repr√©sente un concept, une id√©e ou toute entit√© du monde physique (telle qu'une voiture,
une personne, un point dans le plan, etc.).

- `class` est un mot-cl√© permettant de d√©finir une classe.
- `__init__` est une m√©thode sp√©ciale appel√©e constructeur, elle est appel√©e lors de la cr√©ation d'un objet de la classe `Point`.
- `self` est une r√©f√©rence √† l'objet lui-m√™me.
- `self.x` et `self.y` sont des attributs de l'objet.
- `distance` est une m√©thode de l'objet.
- `other` est un autre objet de la classe `Point`.

:::

## Classes

<br>

Instanciation et utilisation :

```{python}
#| echo: true
p1 = Point(2, 6)
p2 = Point(9, 9)

print('Distance = ', p1.distance(p2))
```

## Classes, m√©thodes et attributs

::::{.columns .medium}

:::{.column .fragment width="50%"}
**M√©thodes** :

Une m√©thode est une fonction qui appartient √† une classe. Elle s'applique donc √† l'instance de la classe sur laquelle elle est appel√©e.

Dans les exemples pr√©c√©dents, nous avons d√©j√† utilis√© des m√©thodes :

- `append`, `remove` et `pop` sont des m√©thodes de la classe `list`
- `keys`, `get` et `values` sont des m√©thodes de la classe `dict`
- etc.

:::

:::{.column .fragment width="50%"}
**Attributs** :

Un attribut est une variable qui appartient √† une classe. Elle est donc accessible depuis toutes les instances de la classe.

```{python}
#| echo: true
p = Point(2, 6)
print(p.x)
```

:::

::::


## √âcosyst√®me pour le g√©ospatial

:::{.medium}

L'√©cosyst√®me Python est tr√®s riche et il existe de nombreuses biblioth√®ques pour le traitement de donn√©es g√©ospatiales.

:::

## Donn√©es vectorielles

::::{.small}

-   [**Bindings Python de GDAL/OGR**](https://gdal.org/api/python_bindings.html) [@GDAL]
-   [**Fiona**](https://fiona.readthedocs.io/en/stable/) [@fiona] - I/O (*wrapper* de haut niveau autour d'OGR)
-   [**Shapely**](https://shapely.readthedocs.io/)  [@sgillies_2023] - bindings Python de [GEOS](https://github.com/libgeos/geos) [@GEOS]
-   [**Pyproj**](https://pyproj4.github.io/pyproj) [@pyproj] - bindings Python de [PROJ](https://proj.org/) [@PROJ]
-   [**Geopandas**](https://geopandas.org/)  [@kelsey_jordahl_2020_3946761] - √âtend les `DataFrame`s de [pandas](https://pandas.pydata.org/) [@pandas]

::::

::::{.columns}
:::{.column width="50%"}

![](./images/logo-pandas.svg){width=300}

:::

:::{.column width="50%"}

![](./images/logo_geopandas.svg){width=340}

:::
::::

## Le package *GeoPandas*

:::{.medium}

Un projet open source pour faciliter le travail avec des donn√©es g√©ospatiales vectorielles en Python. GeoPandas √©tend Pandas pour permettre de disposer d'un type de colonne g√©om√©trique et pour permettre d'effectuer des op√©rations spatiales. Les op√©rations g√©om√©triques sont r√©alis√©es avec `shapely`, les acc√®s en lecture / √©criture aux fichiers utilisent `fiona` et la visualisation utilise `matplotlib`.

![Format des GeoDataFrame](./images/geopandas-table.png)

:::

## Le package *GeoPandas* - Exemples

::: {.panel-tabset .custom-tab .small}

### Import et lecture

```{python gpd-tuto-import-1}
#| echo: false
import geodatasets

file_path = geodatasets.get_path("nybb")
```

Avec la fonction `read_file` :

```{python gpd-tuto-import-2}
#| echo: true
import geopandas as gpd

nybb = gpd.read_file(file_path)
```

### Affichage

Avec la m√©thode `plot` des `GeoDataFrame` :

```{python gpd-tuto-plot}
#| echo: true
nybb.plot()
```

### SCR

Affichage :

```{python gpd-tuto-crs}
#| echo: true
print(nybb.crs)
```

Transformation :

```{python gpd-tuto-transformation}
#| echo: true
nybb_geo = nybb.to_crs('EPSG:4326')
```

### Affichage avec fond de carte

En utilisant la biblioth√®que `contextily` :

```{python gpd-tuto-contextily}
#| echo: true
import contextily as cx

ax = nybb.to_crs('EPSG:3857').plot()
cx.add_basemap(ax, source='https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png')
ax.set_axis_off()
ax
```

### Centroide

Simplement en utilisant l'attribut `centroid` des `GeoDataFrame` :

```{python gpd-tuto-centroid}
#| echo: true
nybb.centroid.plot()
```

### Boundary

Simplement en utilisant l'attribut `boundary` des `GeoDataFrame` :

```{python gpd-tuto-boundary}
#| echo: true
nybb.boundary.plot()
```

### Zone tampon

En utilisant la m√©thode `buffer` des `GeoDataFrame` :

```{python gpd-tuto-buffer}
#| echo: true
buff_nybb = nybb.buffer(3000)
```

```{python gpd-tuto-buffer-2}
#| echo: true
ax = buff_nybb.plot(color="red")
nybb.plot(ax=ax, color="aliceblue")
```


### Aggr√©gation

En utilisant la m√©thode `dissolve` des `GeoDataFrame` :

```{python gpd-tuto-agg}
#| echo: true
# On peut utiliser dissolve(by="nom_colonne") si on veut aggr√©ger selon les valeurs d'une colonne
agg = nybb.dissolve()
agg.plot()
```


### Intersection

En utilisant la m√©thode `intersection` des `GeoDataFrame` :

```{python gpd-tuto-intersection}
#| echo: true
from shapely import wkt

point = wkt.loads('Point(998769.1146889535 174169.7607268664)')
intersecting = nybb.intersection(point.buffer(35000))
```

<br />

```{python gpd-tuto-intersectiob-2}
#| echo: true
ax = nybb.plot()
ax = intersecting.plot(ax=ax, color="red")
ax
```

:::


## Donn√©es raster

::::{.columns .medium}

:::{.column width="50%"}

[**Rasterio**](https://rasterio.readthedocs.io/) [@gillies_2019] :

:::{.small}

* lecture / √©criture de raster (*wrapper* de haut niveau autour de GDAL)
* donn√©es repr√©sent√©es sous forme d'`array` NumPy
* reprojection
* _resampling_
* _virtual files_
* etc.

:::

:::

:::{.column width="50%"}

[**Rasterstats**](https://pythonhosted.org/rasterstats/) :

:::{.small}

* r√©sumer des donn√©es raster sur la base de g√©om√©tries vectorielles
* extraction de valeurs √† un point pr√©cis

:::

[**xarray**](https://docs.xarray.dev/en/stable/) [@xarray] et [**rioxarray**](https://corteva.github.io/rioxarray/) [@rioxarray]:

:::{.small}

* *xarray* pour travailler avec des tableaux multidimensionnels √©tiquet√©s
* *rioxarray* pour ouvrir des jeux des donn√©es raster avec *rasterio*, les stocker dans le format de *xarray*, et avoir acc√®s √† diff√©rentes fonctionnalit√©s de *rasterio*
* moins "rustique" que d'utiliser rasterio seul / d√©pend de l'usage souhait√©

:::

:::
::::

## Le package *Rasterio*

:::{.small}

Exemple d'utilisation :

```{python example-rio-1}
#| echo: true
import rasterio as rio

with rio.open('./data/MODIS_ARRAY.nc') as f:
    # M√©tadonn√©es :
    metadata = f.meta
    # Lire toutes les bandes :
    data = f.read()
    # Ou f.read(1) pour lire seulement la premi√®re bande
```

- Un dictionnaire de m√©tadonn√©es + un tableau NumPy contenant la (ou les) bande(s) :

```{python example-rio-2}
#| echo: true
print(metadata)
print(data)
```

:::

## Les package *xarray* et *rioxarray*

Exemple d'utilisation :

::: {.panel-tabset .custom-tab .small}

### Import et lecture

```{python xarray-tuto-import-1}
#| echo: true
import rioxarray
import xarray

xds = xarray.open_dataarray("./data/MODIS_ARRAY.nc")
```

- Un objet de type `xarray.DataArray` ou `xarray.Dataset` qui contient les diff√©rentes m√©ta-donn√©es et les donn√©es :

```{python xarray-tuto-import-2}
xds
```

### Compl√©tion des valeurs manquantes

```{python xarray-tuto-na}
#| echo: true
filled = xds.rio.interpolate_na()
```

### Affichage

En utilisant la m√©thode `plot` des objets `xarray.DataArray` (ici apr√®s s√©lection d'un *subset* des donn√©es) :

```{python xarray-tuto-plot}
#| echo: true
import matplotlib.pyplot as plt

fig = plt.figure(figsize=(15, 5))
ax1, ax2 = (fig.add_subplot(131), fig.add_subplot(133))

xds.isel(x=slice(0, 20), y=slice(0, 20)).plot(ax=ax1)
filled.isel(x=slice(0, 20), y=slice(0, 20)).plot(ax=ax2)
```

### SCR

- Affichage :

```{python xarray-tuto-crs-1}
#| echo: true
xds.rio.crs
```

- Transformation :

```{python xarray-tuto-crs-2}
#| echo: true
xds = xds.rio.reproject("EPSG:6623")
```

### D√©coupage

- D√©coupage selon l'emprise des donn√©es contenues dans un `GeoDataFrame` (ici `gdf`) :

```{python xarray-tuto-clipping}
#| echo: true
#| eval: false
clipped = xds.rio.clip(gdf.geometry.values, gdf.crs, drop=False, invert=True)
```

:::


## Analyse spatiale

<img src="./images/logo-pysal.png" style="position: absolute; top: 5px; right: 20px; width: 120px; height: auto;"/>


:::{.medium}

√âcosyst√®me de biblioth√®ques pour l'analyse spatiale [PySAL](https://pysal.org/) <br />(Python Spatial Analysis Library, @pysal2007) :

:::

:::: {.columns .small}

::: {.column width="50%"}

**Explorer** :

- Analyse exploratoire des donn√©es spatiales (package [esda](https://pysal.org/esda/))
- Analyse de la dynamique des donn√©es spatiales longitudinales (package [giddy](https://pysal.org/giddy/))
- Mesure des in√©galit√©s dans l'espace et dans le temps (package [inequality](https://inequality.readthedocs.io/en/latest/))
- Analyse statistique de motifs ponctuels planaires (package [pointpats](https://pysal.org/pointpats/))
- Mesure de la s√©gr√©gation dans le temps et dans l'espace (package [segregation](https://pysal.org/segregation/))
- Morphom√©trie urbaine (package [momepy](https://docs.momepy.org/en/stable/))

:::

::: {.column width="50%"}

**Mod√©liser** :

- R√©gression g√©ographiquement pond√©r√©e √† plusieurs √©chelles (package [mgwr](https://mgwr.readthedocs.io/en/latest/))
- Mod√®les lin√©aires g√©n√©ralis√©s √©pars (package [spglm](https://spglm.readthedocs.io/en/latest/))
- Mod√®les d'interaction spatiale (package [spint](https://spint.readthedocs.io/en/latest/))
- Mod√®les de r√©gression spatiale (package [spreg](https://spreg.readthedocs.io/en/latest/))
- Mod√®les de composantes de variance √† corr√©lation spatiale √† plusieurs niveaux (package [spvcm](https://github.com/pysal/spvcm))
- *Areal interpolation* et cartographie dasym√©trique (package [tobler](https://pysal.org/tobler/))
- Accessibilit√© spatiale (package [access](https://pysal.org/access/))
- Optimisation spatiale (package [spopt](https://pysal.org/spopt/))

:::

::::


## Autres packages utiles ...

::::{.columns .medium}
:::{.column width="50%"}

- Binding Python pour [GRASS](https://grass.osgeo.org/grass82/manuals/libpython/index.html) + Int√©gration dans les notebooks Jupyter

![Source: <https://grass.osgeo.org/news/2022_06_05_results_student_grant_caitlin/>](./images/grass_jupyter_combo_vis.png)

:::

:::{.column width="50%"}

- [Iris](https://scitools-iris.readthedocs.io/en/stable/) - Analyse et visualisation de donn√©es des sciences de la Terre.

- Pour la cartographie : [cartopy](https://scitools.org.uk/cartopy/docs/latest/) ; [geoviews](https://geoviews.org/) et [geoplot](https://residentmario.github.io/geoplot/) bas√©s sur *cartopy* ; [PyGMT](https://www.pygmt.org/latest/) (selon les usages - pas de solution aussi aboutie que `mapsf` pour les cartes r√©alis√©es en SHS).

![](./images/cartopy.png)

- Un √©cosyst√®me riche pour le g√©ospatial (voir par exemple ici : [https://github.com/sacridini/Awesome-Geospatial#python](https://github.com/sacridini/Awesome-Geospatial#python)) et la visualisation de donn√©es (voir par exemple les outils list√©s par la plateforme [PyViz](https://pyviz.org/tools.html)).

:::
::::

## Ressources pour l'apprentissage de Python

:::{.medium}

- [Le tutoriel de la documentation officielle](https://docs.python.org/fr/3/tutorial/)

- [Le MOOC "Python : des fondamentaux aux concepts avanc√©s du langage" de l'Universit√© C√¥te d'Azur (6 semaines + semaines optionnelles, dont une semaine "√©cosyst√®me data-science")](https://www.fun-mooc.fr/fr/cours/python-3-des-fondamentaux-aux-concepts-avances-du-langage/)
  (selon vos centres d'int√©r√™t, d'autres MOOC comme ["Recherche reproductible : principes m√©thodologiques pour une science transparente"](https://www.fun-mooc.fr/fr/cours/recherche-reproductible-principes-methodologiques-pour-une-science-transparente/) de l'INRIA
  font appel √† Python ainsi qu'√† des comp√©tences transverses comme l'utilisation de Git, du Markdown, etc.)

- [Openclassrooms - Apprenez les bases du langage Python](https://openclassrooms.com/fr/courses/7168871-apprenez-les-bases-du-langage-python) 

- [Cours "Geo-Python" (en anglais - pr√©sente les bases de la programmation en Python pour l'analyse de donn√©es, avec une coloration g√©ospatiale et sans n√©cessiter de connaissances pr√©alables)](https://geo-python-site.readthedocs.io/en/latest/)

- [Tutoriel "Python pour les SHS" (en fran√ßais)](https://python.sdv.univ-paris-diderot.fr/)

:::

:::{.notes}

Introduction √† la programmation Python pour la biologie : https://python.sdv.univ-paris-diderot.fr/

:::

## Ressources Python G√©ospatial

Les ressources qui suivent supposent pour la plupart une connaissance de base du langage Python (boucles, conditions, fonctions, types de base, etc.).
Elles mobilisent les biblioth√®ques Python le plus souvent utilis√©es pour l'analyse de donn√©es et le traitement de donn√©es g√©ospatiales (pandas, geopandas, rasterio, scipy, etc.).

:::{.medium}

- [Livre gratuit "Geocomputation with Python" (en anglais)](https://py.geocompx.org/) [@Dorman2022]

- [Cours "Automating GIS processes" (en anglais)](https://autogis-site.readthedocs.io/en/latest/)

- [Cours "Use Data for Earth and Environmental Science in Open Source Python" (en anglais)](https://www.earthdatascience.org/courses/use-data-open-source-python/)

- [Livre gratuit "Geographic Data Science with Python"](https://geographicdata.science/book/intro.html)

:::

# Partie 2 - Mise en pratique / Exercices

# Partie 3 - Python et QGIS

## Pourquoi Python-QGIS ?

- Lancer des commandes dans la console Python de QGIS

- Cr√©er et utiliser des extensions

- Ex√©cuter automatiquement un programme Python quand QGIS d√©marre

- Cr√©er des algorithmes de traitement

- Cr√©er des fonctions pour des expressions dans QGIS

- Cr√©er des applications personnalis√©es bas√©es sur l‚ÄôAPI QGIS

## L'interface de programmation PyQGIS

## √âtendre les expressions QGIS avec Python

:::{.medium}

Dans QGIS, les *expressions* peuvent √™tre utilis√©es dans diff√©rents m√©canismes de base :
s√©lection par expression, calcul des valeurs d'un champ (calculatrice de champ), r√®gles de style, √©tiquettes, etc.

QGIS prend √©galement en charge les expressions d√©finies par l'utilisateur. Gr√¢ce √† Python, vous pouvez d√©finir vos propres fonctions qui peuvent √™tre utilis√©es dans le moteur d'expression.

:::

## √âtendre les expressions QGIS avec Python

![](./images/expression-custom-function.png)

## √âtendre les expressions QGIS avec Python

![](./images/expression-selection.png)

## √âtendre les expressions QGIS avec Python

![](./images/expression-new-field.png)

## Console Python dans QGIS

:::{.medium}

QGIS fournit une console interactive Python.

Elle peut √™tre ouverte de plusieurs mani√®res : 

- depuis le menu `Extensions > Console Python`
- en utilisant le raccourci clavier <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>P</kbd>`
- en utilisant le bouton <img src="./images/python-console.png" style="display: inline-block; width: 0.8em; height: auto;"/> dans la barre d'outils

Lors de l'utilisation de la console Python dans QGIS, une variable `iface` est d√©j√† existante. Cette variable est une instance de la classe `QgisInterface` et permet d'acc√©der √† la majorit√© des fonctions de QGIS (acc√®s au canevas de la carte, aux couches, aux menus, barres d'outils, etc. etc.).

:::

## Ex√©cuter des commandes dans la console Python

:::{.medium}


:::

## Utiliser les algorithmes de traitement existants

:::{.medium}

QGIS fournit un ensemble d'algorithmes de traitement qui peuvent √™tre utilis√©s dans la console Python, en utilisant le module Python `processing`.

:::

## Cr√©er des algorithmes de traitement

:::{.medium}

:::

## R√©f√©rences sur l'API Python de QGIS

- [PyQGIS developer cookbook (documentation officielle)](https://docs.qgis.org/latest/en/docs/pyqgis_developer_cookbook/index.html)
- [PyQGIS API documentation (documentation officielle)](https://qgis.org/pyqgis/master/)

- [TP Python pour QGIS (TP de 12h donn√© en Licence Pro.)](https://mthh.github.io/TP_PythonQGIS/)
- [QGIS tutorials - Rubrique "Python Scripting (PyQGIS)"](https://www.qgistutorials.com/)

# Partie 4 - Mise en pratique / Exercices

# Outro

## R√©f√©rences

<!-- R√©f√©rence will be added here automatically from 'references.bib' -->



