---
title: "Formation Python pour g√©omaticiens üêçüåè"
author: "Matthieu Viry"
subtitle: "11 D√©cembre 2023"
format:
  revealjs:
    embed-resources: false
    slide-number: true
    show-slide-number: all
    chalkboard: true
    logo: images/logos-footer.png
jupyter: python3
title-slide-attributes:
  data-background-image: images/logos-footer.png
  data-background-size: 42%
  data-background-position: 50% 90%
css: ['static/style.css']
prefer-html: true
bibliography: references.bib
csl: "universite-de-montreal-apa.csl"
lang: fr
---

## Programme de la demi-journ√©e

<br />

:::{.medium}

- **Partie 1** : Introduction √† Python
- **Partie 2** : Mise en pratique / Exercices
- **Partie 3** : Python et QGIS
- **Partie 4** : Mise en pratique / Exercices
- **Conclusion**

**Objectifs** : D√©couvrir le langage de programmation Python et son √©cosyst√®me, et apprendre √† l'utiliser pour r√©aliser des traitements g√©omatiques dans QGIS.

<br />

Rappels des instructions pour installer l'environnement Python : [Installation d'un environnement Python pour Windows avec Anaconda et VSCodium](installation.html)

:::

# Partie 1 - Introduction √† Python

## Pourquoi programmer ?

- **Automatiser** des t√¢ches r√©p√©titives
- **Prendre le contr√¥le** des analyses et des traitements que vous r√©alisez
- **R√©aliser des analyses reproductibles**
- Pour le fun ! üéâ

:::{.fragment}

**Et pourquoi en Python ?**

- C'est un des langages de programmation les plus populaires et les plus utilis√©s dans le monde
- C'est un langage relativement simple √† apprendre

:::

## Historique et pr√©sentation sur le papier...

<img src="images/logo-python.png" style="position: absolute;top: 60px;right: 10px;width: 105px !important;height: auto;" />

<br /><br />

- Langage cr√©√© √† la toute fin des ann√©es 80 - premi√®re version publique sortie en 1991.

- **Libre** (r√©git par la *Python Software Foundation License*, √©quivalent √† BSD)

- Langage **polyvalent**, **interpr√©t√©**, **multi-paradigme** (imp√©ratif, fonctionnel, OO, ..)

- **Typage dynamique fort** (et *duck typing*)

- Toujours en d√©veloppement actif (derni√®re version stable en octobre 2023)

::: {.notes}


En 1989 aux Pays-Bas, Guido van Rossum invente le langage de programmation Python.
C‚Äôest un fan de la s√©rie t√©l√©vis√©e Monty Python‚Äôs Flying Circus, donc pour rendre un hommage √† la s√©rie il donne le nom Python.
Ce n‚Äôest qu‚Äôen 1991 que la premi√®re version de ce langage a √©t√© publi√©e.

C‚Äôest la Python Software Foundation qui se charge de d√©velopper Python et de faire vivre la communaut√© de d√©veloppeurs et utilisateurs.


- Il est multiplateforme : fonctionne sur des nombreux syst√®mes d‚Äôexploitation ;
- C'est un logiciel libre
- C‚Äôest un langage interpr√©t√© : le script python est directement ex√©cut√©, il n‚Äôa pas besoin d‚Äô√™tre compil√© avant d‚Äô√™tre ex√©cut√© ;
- C‚Äôest un langage orient√© objet : on peut cr√©er des programmes qui imite le comportement du monde r√©el ;
- Enfin, il est notamment utilis√© en bio-informatique, et plus couramment en analyse de donn√©es.


Sur le site web, la description en une phrase du projet est "Python is a programming language that lets you work quickly and integrate systems more effectively"

Pour sa part le projet **R** na√Æt en 1993 comme un projet de recherche de Ross Ihaka et Robert Gentleman √† l'universit√© d'Auckland.

- C'est une impl√©mentation du langage **S** (d√©velopp√© au milieu des ann√©es 70 dans les laboratoires Bell)

- **Libre** (licence *GNU GPL*)

- Langage **interpr√©t√©**, **multi-paradigme** (imp√©ratif, fonctionnel, OO, ..)

- **Typage dynamique**

- Toujours en d√©veloppement actif (derni√®re version en avril 2023)


Sur le site web, le titre est "The R Project for Statistical Computing" et la description en une phrase du projet est : "R is a free software environment for statistical computing and graphics".

:::

## Python

:::{.center}

![](images/xkcd-python.png)

:::
   
## Python vs. R ü•ä

<br>

:::: {.columns}

::: {.column .medium width="50%"}

### Python

- *General-purpose programming language*

- *"Jack of all trades, master of none"* ?

- Utilis√© par Google, Facebook, Microsoft, etc.

:::

::: {.column .medium width="50%"}

### R

- *For statistical computing and graphics*

- *"By statisticians, for statisticians"*

- Utilis√© par Google, Facebook, Microsoft, etc.

:::

::::

<br />

:::{.small}

- Les deux langages sont souvent compar√©s, notamment dans le domaine de l'analyse de donn√©es.

- La question se pose car Python est de plus en plus comp√©tent pour l'analyse de donn√©es...

:::

# Pr√©sentation de l'√©cosyst√®me

## Impl√©mentation de r√©f√©rence et distributions

- Une impl√©mentation de r√©f√©rence du langage [**Python**](https://www.python.org/) : [**CPython**](https://github.com/python/cpython)
  (mais d'autres impl√©mentations : Jython, IronPython, PyPy, etc.)

- Plusieurs *distributions* de Python (principalement [**Anaconda**](https://anaconda.org/), une distribution des langages de programmation Python et R d√©di√©e √† la science des donn√©es et √† l'apprentissage automatique)

<div class="center">
<img src="images/logo-anaconda.png" />
<p class="small">Source: <a href="https://anaconda.org">anaconda.org</a></p>
</div>

::: {.notes}

- CPython est l'impl√©mentation de r√©f√©rence de Python. C'est la version que la plupart des gens utilisent, notamment parce qu'elle est la plus facile √† installer et √† utiliser. Il est √©crit en langage C et est maintenu par la Python Software Foundation.

- Jython est une impl√©mentation de Python √©crite en Java. Il permet aux d√©veloppeurs d'√©crire des programmes Python qui peuvent √™tre ex√©cut√©s sur n'importe quelle machine virtuelle Java (JVM). Cela le rend particuli√®rement utile pour les d√©veloppeurs qui travaillent dans un environnement Java.

- IronPython est une impl√©mentation de Python √©crite en C# et destin√©e √† √™tre utilis√©e dans l'environnement .NET. Il permet aux d√©veloppeurs d'√©crire des programmes Python qui peuvent √™tre ex√©cut√©s sur la plate-forme .NET. Il est particuli√®rement utile pour les d√©veloppeurs qui travaillent dans un environnement .NET.

- PyPy est une impl√©mentation alternative de Python qui est destin√©e √† √™tre plus rapide que CPython. Il est √©crit en langage RPython et utilise une technique d'optimisation appel√©e compilation √† la vol√©e pour acc√©l√©rer l'ex√©cution des programmes.


Anaconda est une distribution gratuite et open source de Python et R, qui a √©t√© d√©velopp√©e pour simplifier le processus
d'installation et de gestion des packages, ainsi que le processus
de configuration et de gestion des environnements de d√©veloppement scientifique de donn√©es.

Il a √©t√© cr√©√© par Continuum Analytics, une entreprise qui a depuis √©t√© acquise par Anaconda, Inc.

Anaconda est livr√© avec une gamme compl√®te de biblioth√®ques scientifiques et de packages pr√©install√©s,
tels que NumPy, pandas, Matplotlib, SciPy, scikit-learn, TensorFlow et Jupyter Notebook, pour n'en citer que quelques-uns.
Il est √©galement facile √† √©tendre avec des packages tiers, en utilisant le gestionnaire de packages conda, qui permet de t√©l√©charger et d'installer des packages √† partir de sources externes.

L'un des avantages les plus importants d'Anaconda est son syst√®me de gestion d'environnement,
qui permet de cr√©er des environnements Python isol√©s pour diff√©rents projets.

:::

## Environnements de d√©veloppement

- Plusieurs IDE appr√©ci√©s par les utilisateurs de Python : [**Spyder**](https://www.spyder-ide.org/) (IDE "scientifique", interface comparable √† RStudio),
  [**PyCharm**](https://www.jetbrains.com/pycharm/) (logiciel propri√©taire, plut√¥t pour d√©velopper des biblioth√®ques), [**Jupyter Lab**](https://jupyter.org/)
  et plus r√©cemment [**Visual Studio Code**](https://code.visualstudio.com/) (VSCode, VSCodium).


<img src="images/spyder.png" style="float:left; width: 46%;" />

<img src="https://www.jetbrains.com/pycharm/img/screenshots/complexLook@2x.jpg" style="float:right; width: 46%;"/>

## *Batteries included üîã*

:::{.medium}

Le langage de programmation Python a une biblioth√®que standard tr√®s compl√®te, comportant de nombreux modules qui permettent de r√©aliser des t√¢ches courantes sans avoir √† r√©inventer la roue.

:::

:::{.small}

[Modules de la biblioth√®que standard](https://docs.python.org/3/library/index.html) :

- `math` (fonctions math√©matiques de base)
- `statistics` (statistiques descriptives)
- `random` (g√©n√©ration de nombres al√©atoires)
- `datetime` (gestion des dates et heures)
- `os` (fonctions d'interaction avec le syst√®me d'exploitation)
- `sys` (fonctions et variables d'interaction avec l'interpr√©teur Python)
- `re` (expressions r√©guli√®res)
- `csv` (lecture et √©criture de fichiers CSV)
- `json` (lecture et √©criture de fichiers JSON)
- `sqlite3` (interface avec la base de donn√©es SQLite)
- etc.

:::

## Modules additionnels (biblioth√®ques)

<br />

:::{.medium}

Une des forces du langage de programmation Python est son √©cosyst√®me, qui est tr√®s riche et tr√®s actif.

Les packages sont des biblioth√®ques Python qui peuvent √™tre install√©es √† l'aide du gestionnaire de packages `pip` (ou `conda` dans le cas d'Anaconda).

Ces packages sont g√©n√©ralement h√©berg√©s sur [PyPI](https://pypi.org/) (Python Package Index) (et [conda-forge](https://conda-forge.org/) pour les utilisateurs d'Anaconda).

**Avant de se lancer dans une t√¢che de programmation, il est donc important de v√©rifier si un package sp√©cialis√© existe d√©j√† pour r√©aliser cette t√¢che**.

:::

:::{.notes}

Il est fr√©quent de se dire "je vais √©crire un programme pour faire √ßa" et de se lancer dans le d√©veloppement d'un programme Python.
Mais avant de se lancer dans une t√¢che de programmation, il est important de v√©rifier si un package sp√©cialis√© existe d√©j√† pour r√©aliser cette t√¢che.
Si c'est le cas, ces auteurs ont d√©j√† fait le travail de d√©veloppement et de test, et il est probable que leur package soit plus robuste et plus performant que ce que vous pourriez √©crire vous-m√™me
(il n'est pas rare de sous-estimer les difficult√©s qui pourraient √™tre rencontr√©es lors du d√©veloppement d'un programme, l√† o√π un package existant g√®re peut-√™tre d√©j√† ces difficult√©s).

:::

## Modules additionnels (biblioth√®ques)

**√âcosyst√®me Python scientifique**

<br />
<center>

![](images/python-stack.png)

</center>

## Documentation

::: {.small}
Un point fort de Python est sa documentation officielle, qui contient tout le n√©cessaire pour utiliser le langage de mani√®re proactive
(tutoriel, r√©f√©rence de l'ensemble des fonctions et des objets de tous les modules de la biblioth√®que standard, etc.)
et qui est mise √† disposition dans plusieurs langues (Anglais, Fran√ßais, Espagnol, Cor√©en, Japonais, Chinois, etc.).
:::

<center>

![](images/python-documentation.png)

</center>


## Documentation / Modules additionnels


Il n'existe toutefois pas un seul standard pour consulter la documentation des diff√©rents modules additionnels Python
(cf. [Documentation Matplotlib](https://matplotlib.org/stable/api/index), [Documentation pandas](https://pandas.pydata.org/docs/reference/index.html#api)).

<img src="images/doc-geopandas.png" style="width: 40%; position: absolute; border: solid 1px black; left: 10px;" />

<img src="images/doc-matplotlib.png" style="width: 40%; position: absolute; border: solid 1px black; bottom: -60px; left: 29%;" />

<img src="images/doc-samgeo.png" style="width: 40%; position: absolute; border: solid 1px black; right: 10px;" />

# En terme de syntaxe √ßa donne quoi ?

## Premier pas avec la syntaxe Python

<br>

```{python}
#| error: true
#| echo: true
#| message: true
#| cache: true
import math # On importe le module math
# Et deux fonctions du module statistics
from statistics import mean, stdev

# D√©finition d'une fonction
def cv(x):
    moy = mean(x)
    s = stdev(x)
    result = s / moy
    # Retourne le r√©sultat
    return result 

# La fonction est appel√©e avec une liste de valeurs,
# et le r√©sultat est stock√© dans une variable 
res = cv([5, 6, 3, 8, 9, 12])

# Affichage du r√©sultat
print(res)
```

## Python et l'indentation du code...

<br>

```{python}
#| error: true
#| echo: true
#| message: true
#| cache: true
my_list = [1, 2, 3]

for item in my_list:
    if item % 2 == 0:
        print('even')
    else:
    print('odd')
```

## Python et l'indentation du code...

<br>

```{python}
#| error: true
#| echo: true
#| message: true
#| cache: true
my_list = [1, 2, 3]

for item in my_list:
    if item % 2 == 0:
        print('even')
    else:
        print('odd')
```

## Python et l'indentation du code...

<br>

- Respecter les r√®gles d‚Äôindentations est *obligatoire* en Python.

- Ce n'est pas une *contrainte* lors d'une session de travail car les IDE guident la position du curseur.

- Cette indentation a un r√¥le direct sur le contr√¥le du flux d'ex√©cution.

- Elle permet notamment d'√©viter l'utilisation d'accolades (*curly brackets*) pour d√©limiter les blocs et de point-virgules pour d√©limiter les instructions.


## Python et l'indentation du code...

<br>

Le code qui suit est volontairement incorrect mais ne g√©n√®re pas d'erreur lors de l'ex√©cution :

```{python}
#| echo: true
li1 = [1, 2, 3, 4, 5, 6]
li2 = [4, 20, 31, 87, 123, 621]

# Additionnons les deux listes, √©l√©ments par √©l√©ments,
# et stockons chaque r√©sultat dans une nouvelle liste
result = []

for item1, item2 in zip(li1, li2):
    new_item = item1 + item2
result.append(new_item)

print(result)
```

## Python et l'indentation du code...

<br>

Une fois l'indentation corrig√©e...

```{python}
#| echo: true
li1 = [1, 2, 3, 4, 5, 6]
li2 = [4, 20, 31, 87, 123, 621]

# Additionnons les deux listes, √©l√©ments par √©l√©ments,
# et stockons chaque r√©sultat dans une nouvelle liste
result = []

for item1, item2 in zip(li1, li2):
    new_item = item1 + item2
    result.append(new_item)

print(result)
```

<!-- # Premi√®res commandes dans l'interpr√©teur Python -->

## L'interpr√©teur Python

<br>

:::{.medium}

- L'interpr√©teur Python est un programme qui lit et ex√©cute du code Python.
- Il est possible d'interagir avec l'interpr√©teur Python en utilisant un terminal (ou une console) ou en utilisant un IDE.
- L'interpr√©teur Python est lanc√© en tapant `python` dans un terminal.
- Il est possible de quitter l'interpr√©teur Python en tapant `exit()` ou en appuyant sur `Ctrl + D`.
- L'interpr√©teur Python peut √™tre utilis√© pour ex√©cuter des scripts Python (fichiers `.py`) en utilisant la commande `python mon_script.py`.

:::

## Ouvrir l'interpr√©teur Python (install√© par Anaconda)

<br />

:::{.small}

- Dans le menu D√©marrer, chercher "Anaconda Prompt" et cliquer dessus. Une fen√™tre de terminal s'ouvre. Celle-ci est pr√™te √† ex√©cuter des commandes Python (dans l'environnement de base d'Anaconda).

- Il est possible d'installer des packages Python suppl√©mentaires dans l'environnement de base d'Anaconda en utilisant des commandes telles que :
  - `conda install mon_package` (pour installer un package depuis le d√©p√¥t Anaconda)
  - `pip install mon_package` (pour installer un package depuis le d√©p√¥t PyPI)
  - `conda install --channel conda-forge mon_package` (pour installer un package depuis le d√©p√¥t conda-forge)

- Il est possible de lancer un interpr√©teur Python en tapant `python` dans le terminal.

üöÄ **Ouvrez un terminal et lancez l'interpr√©teur Python ! Lors des d√©monstrations qui suivent, vous pourrez tester les commandes dans l'interpr√©teur Python.** üöÄ

:::


## Calculs simples et variables

<br />

:::{.medium}

Une des premi√®res fonctionnalit√©s que l'on souhaite tester dans un langage de programmation est la possibilit√© d'effectuer des calculs simples.

```
>>> 1 + 2
3
>>> 3 * 4
12
```

Vous pouvez ou non utiliser des espaces autour des op√©rateurs (`+`, `-`, `*`, `/`, etc.) :

```
>>> 1+2
3
```

La double √©toile repr√©sente l'exposant.

```
>>> 2 ** 3
8
```

:::

## Calculs simples et variables

<br />

:::{.medium}

Il est possible de stocker des valeurs dans des variables :

```
>>> a = 1
>>> b = 2
>>> result = a + b
```

Le r√©sultat n'est donc plus affich√© directement dans l'interpr√©teur Python mais stock√© dans la variable `result`.
On peut ensuite afficher le contenu de la variable `result` :

```
>>> result
3
```

Ou en utilisant la fonction `print` :

```
>>> print(result)
```

:::

## Calculs simples et variables

:::{.medium}

En Python le typage est dynamique, il n'est pas n√©cessaire de d√©clarer le type d'une variable avant de l'utiliser et il est possible de changer le type d'une variable
au cours de son existence :

```
>>> a = 1
>>> type(a)
<class 'int'>
>>> a = 'Hello world!'
>>> type(a)
<class 'str'>
```

:::


# Types natifs <br />et *data structures* natives

:::{.small}
*Les structures de donn√©es sont les √©l√©ments fondamentaux autour desquels vous construisez vos programmes. Chaque structure de donn√©es fournit une mani√®re particuli√®re d'organiser les donn√©es afin d'y acc√©der efficacement.*
:::

## Types de base

Les types de base sont les types de donn√©es les plus simples disponibles dans Python. Ils sont utilis√©s pour repr√©senter des valeurs simples.

::::{.columns .medium}
:::{.column width="50%"}

- `int` (entier)

```{python}
#| echo: true
my_int = 42
```

- `float` (nombre √† virgule flottante)

```{python}
#| echo: true
my_float = 3.14
```

- `bool` (bool√©en)

```{python}
#| echo: true
my_bool = True # ou False
```

:::

:::{.column width="50%"}

- `str` (cha√Æne de caract√®res)

```{python}
#| echo: true
my_str = 'Hello world!'
```

- `NoneType` (type sp√©cial pour la valeur `None`)

```{python}
#| echo: true
my_none = None
```

:::
::::

## Types de base - `str`

::::{.columns .medium}

:::{.column width="50%"}

- **Cr√©ation**, avec des guillemets simples ou doubles :

```{python}

#| echo: true
my_str = 'Hello world!'
```

```{python}
#| echo: true
my_str = "Hello world!"
```

<br />

- **Concat√©nation** :

```{python}

#| echo: true
my_str = 'Hello' + ' ' + 'world!'
```

:::

:::{.column width="50%"}

- **Acc√®s aux caract√®res** :

```{python}

#| echo: true
print(my_str[0]) # Premier caract√®re
```

```{python}
#| echo: true
print(my_str[-1]) # Dernier caract√®re
```

```{python}
#| echo: true
print(my_str[0:5]) # Sous-cha√Æne
```

:::

::::

## Types de base - `str`

::::{.columns .medium}

:::{.column width="50%"}

- **Formatage** :

```{python}
#| echo: true
a = 'world'

my_str = 'Hello {}!'.format(a)
print(my_str)
```

```{python}
#| echo: true
a = 'world'

my_str = f'Hello {a}!'
print(my_str)
```

:::

:::{.column width="50%"}

- **Remplacement** :

```{python}
#| echo: true
my_str = 'Hello world!'
my_str = my_str.replace('world', 'Python')
print(my_str)
```

:::{.medium}

La m√©thode `replace` retourne une nouvelle cha√Æne de caract√®res, la cha√Æne de caract√®res initiale n'est pas modifi√©e.
Cette m√©thode remplace toutes les occurrences de la sous-cha√Æne par la nouvelle sous-cha√Æne.

Elle peut aussi √™tre utilis√©e pour supprimer une sous-cha√Æne :

:::

```{python}
#| echo: true
my_str = 'Hello world!'

my_str = my_str.replace(' world', '')
print(my_str)
```

:::

::::

## Structures de donn√©es

:::{.medium}

Python est livr√© avec un ensemble complet de structures de donn√©es dans sa biblioth√®que standard :


- `dict` (tableau associatif)

```{python}
#| echo: true
my_dict = { 'john': 32, 'jane': 27, 'jack': 30 }
```

- `tuple` (un conteneur immuable),

```{python}
#| echo: true
my_coordinates = (2.349014, 48.864716)
```

- `list` (tableau dynamique mutable),

```{python}
#| echo: true
my_list = [12, 34, 2, 1, 21, 4]
other_list = ['a', 12, (2.349014, 48.864716), { "foo": 42 }]
```

- `array` (tableau typ√© de base), `enum` (√©num√©ration), etc.

:::

:::{.notes}

En informatique, une structure de donn√©es est une mani√®re d'organiser les donn√©es pour les traiter plus facilement. Une structure de donn√©es est une mise en ≈ìuvre concr√®te d'un type abstrait.

Pour prendre un exemple de la vie quotidienne, on peut pr√©senter des num√©ros de t√©l√©phone par d√©partement, par nom, par profession (comme les Pages jaunes), par num√©ro t√©l√©phonique (comme les annuaires destin√©s au t√©l√©marketing), par rue et/ou une combinaison quelconque de ces classements. √Ä chaque usage correspondra une structure d'annuaire appropri√©e.

En organisant d'une certaine mani√®re les donn√©es, on permet un traitement automatique de ces derni√®res plus efficace et rapide.

Souvent (en tout cas pour les cas qui nous concernent ici) il s'agira de collections d'objets, par exemple un tableau de nombre, 
un tableau associatif (dictionnaire) permettant de faire correspondre des cl√©s (noms par ex) √† des valeurs (num√©ro de t√©l√©phone par ex), etc.

:::

## Structures de donn√©es - `list` (1)

[Les listes sont des tableaux dynamiques, elles peuvent contenir des √©l√©ments de diff√©rents types et sont mutables.]{.medium}

::::{.columns .medium}

:::{.column width="50%"}

- **Cr√©ation** :

Liste vide :

```{python}
#| echo: true
ma_liste = []
```

Ou cr√©ation d'une liste avec des √©l√©ments :

```{python}
#| echo: true
ma_liste = [12, 34, 2, 1, 21, 43]
```

<br />

- **Connaitre la taille d'une liste** :

```{python}
#| echo: true
len(ma_liste)
```

:::

:::{.column width="50%"}

- **Acc√®s aux √©l√©ments** :


```{python}
#| echo: true
ma_liste[0] # Premier √©l√©ment
```

```{python}
#| echo: true
ma_liste[-1] # Dernier √©l√©ment
```

```{python}
#| echo: true
ma_liste[1] = 42 # Modification d'un √©l√©ment
```

<br />

- **Acc√®s √† un sous-ensemble d'√©l√©ments** (*slicing*) :

```{python}
#| echo: true
my_slice = ma_liste[1:3]
my_slice
```

:::
::::

## Structures de donn√©es - `list` (2)

:::{.medium}

De nombreuses *m√©thodes* permettant de manipuler les listes.

- **Ajouter des √©l√©ments √† une liste existante** :

```{python}
#| echo: true
ma_liste.append(322)
```

<br />


- **Supprimer un √©l√©ment d'une liste** :

```{python}
#| echo: true
 # Supprime la premi√®re occurrence de l'√©l√©ment 322
ma_liste.remove(322)
```

```{python}
#| echo: true
 # Supprime l'√©l√©ment √† l'indice 0 (et le retourne)
ma_liste.pop(0)
```

Il existe √©galement des m√©thodes permettant de trier une liste (`sort`), d'ajouter un √©l√©ment √† une position pr√©cise (`insert`), etc. etc.

:::

## Structures de donn√©es - `tuple`

:::{.medium}

Puisqu'il s'agit d'un type immuable, il n'est pas possible de modifier un tuple une fois qu'il a √©t√© cr√©√© :

- **Cr√©ation** :

```{python}
#| echo: true
my_tuple = (1, 2, 3)
```

- **Acc√®s aux √©l√©ments** :

```{python}
#| echo: true
my_tuple[0] # Comme pour une liste
```

- **Pas de modification possible** :

```{python}
#| error: true
#| echo: true
my_tuple[0] = 42
```

:::


## Structures de donn√©es - `dict` (1)

:::{.medium}

Il s'agit d'un tableau associatif, les √©l√©ments sont stock√©s sous forme de cl√© / valeur. Il ne s‚Äôagit donc pas d‚Äôobjets s√©quentiels comme les listes, mais plut√¥t d‚Äôobjets dits de correspondance (*mapping objects* en anglais).

:::

::::{.columns .medium}

:::{.column width="50%"}

- **Cr√©ation** d'un dictionnaire **vide** :

```{python}
#| echo: true
my_dict = {}
```

<br />

- **Cr√©ation** d'un dictionnaire **avec des √©l√©ments** :

```{python}
#| echo: true
my_dict = { 'john': 32, 'jane': 27, 'jack': 30 }
```

<br />

- **Acc√®s aux √©l√©ments** :

```{python}
#| echo: true
my_dict['john']
```

:::

:::{.column width="50%"}

- **Modification d'un √©l√©ment** :

```{python}
#| echo: true
my_dict['john'] = 33
```

<br />

- **Ajout d'un √©l√©ment** :

```{python}
#| echo: true
my_dict['jill'] = 29
```

<br />

- **Suppression d'un √©l√©ment** :

```{python}
#| echo: true
del my_dict['john']
```

:::

::::

## Structures de donn√©es - `dict` (2)

::::{.columns .medium}

:::{.column width="50%"}

- **Acc√®s aux √©l√©ments** :

```{python}
#| echo: true
my_dict['jill']
```

<br />

*Une erreur est renvoy√©e si la cl√© n'existe pas* :

```{python}
#| error: true
#| echo: true
my_dict['johana']
```

<br />

*Tester l'existence d'une cl√© dans un dictionnaire* :

```{python}
#| echo: true
'johana' in my_dict
```

:::

:::{.column width="50%"}

*Demander la valeur associ√©e √† une cl√© en utilisant la m√©thode `get` (et de sp√©cifier une valeur par d√©faut si la cl√© n'existe pas)* :

```{python}
#| echo: true
my_dict.get('johana')
```

```{python}
#| echo: true
my_dict.get('johana', -1)
```


<br />

- **R√©cup√©rer l'ensemble des cl√©s** :

```{python}
#| echo: true
my_dict.keys()
```

<br />

- **R√©cup√©rer l'ensemble des valeurs** :

```{python}
#| echo: true
my_dict.values()
```

:::

::::

## Des listes de listes ?

:::{.medium}

Il est possible et fr√©quent de combiner des listes (ou des listes et des tuples) pour repr√©senter des donn√©es tabulaires :

```{python}
#| echo: true
data = [
    ['Jill', 32, 1.65],
    ['Jack', 27, 1.73],
    ['Jane', 30, 1.80]
]

print(data[0][1])
```

```{python}
#| echo: true
data = [
    ('Jill', 32, 1.65),
    ('Jack', 27, 1.73),
    ('Jane', 30, 1.80)
]

print(data[0][1])
```

:::

## Des listes de dictionnaires ?

:::{.medium}

Il est √©galement classique de combiner des listes et des dictionnaires pour repr√©senter, par exemple, des donn√©es tabulaires :

```{python}
#| echo: true
data = [
    { 'name': 'Jill', 'age': 32,  'height': 1.65 },
    { 'name': 'Jack', 'age': 27,  'height': 1.73 },
    { 'name': 'Jane', 'age': 30,  'height': 1.80 }
]

print(data[0]['age'])
```

:::

## Contr√¥le du flux d'ex√©cution - `if`

:::{.medium}

Le contr√¥le du flux d'ex√©cution permet de contr√¥ler l'ordre dans lequel les instructions sont ex√©cut√©es.

:::

::::{.columns .medium}

:::{.column width="50%"}

- **`if`** :

```{python}
#| echo: true
altitude = 2500

if altitude >= 2000:
    print('Haute altitude')
```

<br />

- **`if` / `else`** :

```{python}
#| echo: true
altitude = 2500

if altitude >= 2000:
    print('Haute altitude')
else:
    print('Basse altitude')
```

:::

:::{.column width="50%"}

- **`if` / `elif` / `else`** :

```{python}
#| echo: true
altitude = 2500

if altitude >= 6000:
    print('Altitude extr√™mement √©lev√©e')
elif altitude >= 4000:
    print('Tr√®s haute altitude')
elif altitude >= 2000:
    print('Haute altitude')
else:
    print('Basse altitude')
```

[Les seuils proviennent de [Wikipedia:Altitude#Adaptations_physiologiques_et_r√©ponses_physiopathologiques_du_corps_humain](https://fr.wikipedia.org/wiki/Altitude#Adaptations_physiologiques_et_r%C3%A9ponses_physiopathologiques_du_corps_humain)]{.very-small}

:::

::::

## Contr√¥le du flux d'ex√©cution - `for` (1)

:::{.medium}

La boucle `for` permet d'it√©rer sur une s√©quence (une liste, un tuple, un dictionnaire, etc.) :

:::

::::{.columns .medium}

:::{.column width="50%"}

- **`for`** :

```{python}
#| echo: true
for i in range(5):
    print(i)
```

<br />

Ici, `range()` est une fonction native qui retourne une s√©quence d'entiers :

- `range(5)` retourne la s√©quence `0, 1, 2, 3, 4`.

- `range(2, 7)` retourne la s√©quence `2, 3, 4, 5, 6`.

:::

:::{.column width="50%"}

- **`for`** sur une liste :

```{python}
#| echo: true
my_list = [12, 34, 2, 1, 3]

for item in my_list:
    print(item)
```

<br />

- **`for`** sur une liste, en utilisant `enumerate` :

```{python}
#| echo: true
for index, item in enumerate(my_list):
    print(f'Index: {index}, item: {item}')
```

:::

::::

## Contr√¥le du flux d'ex√©cution - `for` (2)

::::{.columns .medium}

:::{.column width="50%"}

- **`for`** sur un dictionnaire :

```{python}
#| echo: true
my_dict = { 'john': 32, 'jane': 27, 'jack': 30 }

for key in my_dict:
    print(key)
```

<br />

```{python}
#| echo: true
for key, value in my_dict.items():
    print(f'{key} a {value} ans')
```

:::

:::{.column width="50%"}

- **`for`** sur une cha√Æne de caract√®res :

```{python}
#| echo: true

for letter in 'Hello !':
    print(letter)
```

<br />

```{python}
#| echo: true

for letter in 'Hello !':
    if letter.lower() in 'aeiouy':
        print(letter)
```

:::

::::

## Contr√¥le du flux d'ex√©cution - `while`

:::{.medium}

La boucle `while` permet d'ex√©cuter un bloc d'instructions tant qu'une condition est vraie :

:::

::::{.columns .medium}

:::{.column width="50%"}

- **`while`** :

```{python}
#| echo: true
i = 0

while i < 5:
    print(i)
    i += 1
```

:::

:::{.column width="50%"}

- **`while`** avec `break` :

```{python}
#| echo: true
i = 0

while True:
    print(i)
    i += 1
    if i >= 5:
        break
```

:::

::::

## Fonctions

:::{.medium}

Les fonctions permettent de regrouper des instructions et de les ex√©cuter plusieurs fois, en leur passant des param√®tres diff√©rents.

:::

::::{.columns .medium}

:::{.column width="50%"}

- **D√©finition d'une fonction** :

```{python}
#| echo: true
def my_function():
    print('Hello world!')
```

<br />

- **Appel d'une fonction** :

```{python}
#| echo: true
my_function()
```

:::

:::{.column width="50%"}

- **Fonction avec param√®tres et valeur de retour** :

```{python}
#| echo: true
def compute_NDVI(red, nir):
    ndvi = (nir - red) / (nir + red)
    return ndvi
```

<br />

```{python}
#| echo: true
ndvi = compute_NDVI(0.2, 0.8)
print(ndvi)
```

:::

::::

## Classes

<br>

[Comme Python est un langage *orient√©-objet*, il est √©galement possible de d√©finir des classes, permettant de facilement mod√©liser des cat√©gories d'objets...]{.medium}


```{python}
#| echo: true
class Point:
    def __init__(self, x, y):
      self.x = x
      self.y = y

    def distance(self, other):
      return (
        (other.x - self.x) ** 2 + (other.y - self.y) ** 2
      ) ** 0.5
```

:::{.notes}

La programmation orient√©e objet (ou programmation par objet) est un paradigme de programmation qui consiste √† mod√©liser des objets du
monde r√©el sous forme de briques logicielles appel√©es *objet*. Un objet repr√©sente un concept, une id√©e ou toute entit√© du monde physique (telle qu'une voiture,
une personne, un point dans le plan, etc.).

- `class` est un mot-cl√© permettant de d√©finir une classe.
- `__init__` est une m√©thode sp√©ciale appel√©e constructeur, elle est appel√©e lors de la cr√©ation d'un objet de la classe `Point`.
- `self` est une r√©f√©rence √† l'objet lui-m√™me.
- `self.x` et `self.y` sont des attributs de l'objet.
- `distance` est une m√©thode de l'objet.
- `other` est un autre objet de la classe `Point`.

:::

## Classes

<br>

Instanciation et utilisation :

```{python}
#| echo: true
p1 = Point(2, 6)
p2 = Point(9, 9)

print('Distance = ', p1.distance(p2))
```

## Classes, m√©thodes et attributs

::::{.columns .medium}

:::{.column .fragment width="50%"}
**M√©thodes** :

Une m√©thode est une fonction qui appartient √† une classe. Elle s'applique donc √† l'instance de la classe sur laquelle elle est appel√©e.

Dans les exemples pr√©c√©dents, nous avons d√©j√† utilis√© des m√©thodes :

- `append`, `remove` et `pop` sont des m√©thodes de la classe `list`
- `keys`, `get` et `values` sont des m√©thodes de la classe `dict`
- etc.

:::

:::{.column .fragment width="50%"}
**Attributs** :

Un attribut est une variable qui appartient √† une classe. Elle est donc accessible depuis toutes les instances de la classe.

```{python}
#| echo: true
p = Point(2, 6)
print(p.x)
```

:::

::::

## Actions courantes : lire et √©crire des fichiers

:::{.medium}

- `open` permet d'ouvrir un fichier en lecture ou en √©criture.
- `read` permet de lire le contenu d'un fichier.
- `write` permet d'√©crire dans un fichier.
- `close` permet de fermer un fichier.
- `with` (il s'agit d'un *context manager*) permet d'ouvrir un fichier et de s'assurer que ce dernier sera bien ferm√© √† la fin du bloc d'instructions.

:::

## Actions courantes : lire et √©crire des fichiers

::::{.columns .medium}
:::{.column width="50%"}

- **Lire le contenu d'un fichier** :

```{python}
#| echo: true
with open('data/data.txt', 'r') as f:
    content = f.read()
    
print(content)
```

- **√âcrire dans un fichier** :

```{python}
#| echo: true
with open('data/test.txt', 'w') as f:
    f.write('Hello world!')
```

:::

:::{.column width="50%"}

- **Lire le contenu d'un fichier ligne par ligne** :

```{python}
#| echo: true
with open('data/data.txt', 'r') as f:
    for line in f:
        print(line)
```

- **√âcrire dans un fichier ligne par ligne** :

```{python}
#| echo: true
with open('data/test.txt', 'w') as f:
    f.write('Hello world!\n')
    f.write('Hello world!\n')
    f.write('Hello world!\n')
```

:::

::::

## Actions courantes : lire et √©crire des fichiers

:::{.small}

Une action tr√®s courante est de lire le contenu d'un fichier pour remplacer une sous-cha√Æne par une autre sous-cha√Æne (ex: changer un chemin d'acc√®s dans un fichier de configuration, etc.).

```{python}
#| echo: true

with open('data/data.txt', 'r') as f:
    content = f.read()

# Si on veut replacer plusieurs sous-cha√Æne
# il suffit d'utiliser la m√©thode `replace` plusieurs fois
content = content.replace('world', 'Python')
content = content.replace('Hello', 'Hi')

with open('data/test.txt', 'w') as f:
    f.write(content)
```

:::

## Actions courantes : lire et √©crire des fichiers

:::{.small}

Il est √©galement possible d'utiliser la biblioth√®que `re` (pour *regular expressions*) pour remplacer une sous-cha√Æne par une autre sous-cha√Æne √† l'aide d'une expression r√©guli√®re.

```{python}
#| echo: true
import re

with open('data/data.txt', 'r') as f:
    content = f.read()

content = re.sub(r'Python', 'world', content)
content = re.sub(r'H[a-z]+', 'Hello', content)

with open('data/test.txt', 'w') as f:
    f.write(content)
```

:::

## Actions courantes : lire et √©crire des fichiers

::::{.columns .medium}

:::{.column width="50%"}

- **Lire le contenu d'un fichier JSON** :

```{python}
#| echo: true
import json

with open('data/data.json', 'r') as f:
    data = json.load(f)

print(data.keys()) # Affiche les cl√©s du dictionnaire
print(data['width']) # Affiche la valeur associ√©e √† la cl√© 'width'
print(data['height']) # Affiche la valeur associ√©e √† la cl√© 'height'
print(data['values']) # Affiche la valeur associ√©e √† la cl√© 'values'
```

:::

:::{.column width="50%"}

- **√âcrire dans un fichier JSON** :

```{python}
#| echo: true
import json

data = { 'name': 'John', 'age': 32 }

with open('data/test.json', 'w') as f:
    json.dump(data, f)
```

:::

::::

## Actions courantes : lire et √©crire des fichiers

::::{.columns .medium}

:::{.column width="50%"}

- **Lire le contenu d'un fichier CSV** :

```{python}
#| echo: true
import csv

with open('data/data.csv', 'r') as f:
    reader = csv.reader(f)
    for row in reader:
        print(row)
```

:::

:::{.column width="50%"}

- **√âcrire dans un fichier CSV** :

```{python}
#| echo: true
import csv

data = [
    ['name', 'age'],
    ['John', 32],
    ['Jane', 27],
    ['Jack', 30]
]

with open('data/test.csv', 'w') as f:
    writer = csv.writer(f)
    writer.writerows(data)
```

:::

::::

## Python pour l'analyse de donn√©es

<br />

:::{.medium}

- Python est un **langage de programmation g√©n√©raliste**, sa biblioth√®que standard n'est pas d√©di√©e √† l'analyse de donn√©es.

- Il existe de **nombreuses biblioth√®ques additionnelles** pour l'analyse de donn√©es (et il s'agit d'un √©cossyst√®me tr√®s riche et vivant).

- La biblioth√®que la plus utilis√©e pour l'analyse de donn√©es est [**pandas**](https://pandas.pydata.org/). Cette biblioth√®que permet de manipuler des donn√©es tabulaires (des tableaux de donn√©es).

- Une autre composante de base de l'√©cosyst√®me Python pour l'analyse de donn√©es est [**NumPy**](https://numpy.org/). Cette biblioth√®que permet de manipuler des tableaux de donn√©es typ√©s de mani√®re efficace (la biblioth√®que pandas est bas√©e sur NumPy).

:::

:::{.notes}

La biblioth√®que NumPy est √©crite en C et en Fortran, elle est donc tr√®s performante. Elle est utilis√©e par de nombreuses autres biblioth√®ques Python pour l'analyse de donn√©es et pour le calcul scientifique.

C'est √©galement le cas pour de nombreuses biblioth√®ques Python pour le g√©ospatial (les rasters seront par exemple repr√©sent√©s sous forme de tableaux NumPy).

:::

## Analyse de donn√©es - `pandas`

:::{.medium}

Pandas permet d'ouvrir des fichiers CSV, JSON, Excel, etc. et de les manipuler facilement gr√¢ce √† des `DataFrame`s (comparables aux `data.frame`s de R).

:::

::::{.columns .medium}

:::{.column width="50%"}

- Ouverture :

```{python}
#| echo: true
import pandas as pd

df = pd.read_csv('data/data.csv')
```

- Affichage :

```{python}
#| echo: true
df.head()
```

:::

:::{.column width="50%"}

- S√©lection d'une colonne :

```{python}
#| echo: true
df['name']
```

- S√©lection selon une condition :

```{python}
#| echo: true
df[df['age'] > 30]
```

```{python}
#| echo: true
df.query('age > 30')
```

:::

::::

## Analyse de donn√©es - `pandas`

::::{.columns .medium}

:::{.column width="50%"}

- Ajout d'une colonne :

```{python}
#| echo: true
df['weight'] = [80, 65, 75, 54, 90]

df['BMI'] = df['weight'] / df['height'] ** 2

df.head()
```

- Suppression d'une (ou plusieurs) colonne(s) :

```{python}
#| echo: true
df.drop(
  columns=['weight', 'height'],
  inplace=True,
)
```

:::

:::{.column width="50%"}

- Tri :

```{python}
#| echo: true
df.sort_values(by='BMI', inplace=True)

df.head()
```

- Export :

```{python}
#| echo: true
df.to_csv('data/test.csv', index=False)
```

:::

::::

## Analyse de donn√©es - `pandas`

::::{.columns .medium}

La biblioth√®que pandas permet √©galement de faire des statistiques descriptives, de r√©aliser simplement des graphiques, etc.

:::{.column width="50%"}

- Visualisation :

```{python}
#| echo: true
df.plot.bar(x='name', y='BMI')
```

:::

:::{.column width="50%"}

- Statistiques descriptives :

```{python}
#| echo: true

df.describe()
```

:::

::::


## Analyse de donn√©es - Autres biblioth√®ques

<br />

:::{.medium}

- [**NumPy**](https://numpy.org/) - Manipulation de tableaux de donn√©es typ√©s
- [**SciPy**](https://www.scipy.org/) - Biblioth√®que d'algorithmes scientifiques
- [**Matplotlib**](https://matplotlib.org/) - Visualisation de donn√©es
- [**Scikit-learn**](https://scikit-learn.org/) - Apprentissage automatique
- [**Statsmodels**](https://www.statsmodels.org/) - Mod√®les statistiques
- [**Seaborn**](https://seaborn.pydata.org/) - Visualisation de donn√©es
- [**Plotly**](https://plotly.com/python/) - Visualisation de donn√©es

:::

## √âcosyst√®me pour le g√©ospatial

:::{.medium}

L'√©cosyst√®me Python est tr√®s riche et il existe de nombreuses biblioth√®ques pour le traitement de donn√©es g√©ospatiales.

:::

## Donn√©es vectorielles

::::{.small}

-   [**Bindings Python de GDAL/OGR**](https://gdal.org/api/python_bindings.html) [@GDAL]
-   [**Fiona**](https://fiona.readthedocs.io/en/stable/) [@fiona] - I/O (*wrapper* de haut niveau autour d'OGR)
-   [**Shapely**](https://shapely.readthedocs.io/)  [@sgillies_2023] - bindings Python de [GEOS](https://github.com/libgeos/geos) [@GEOS]
-   [**Pyproj**](https://pyproj4.github.io/pyproj) [@pyproj] - bindings Python de [PROJ](https://proj.org/) [@PROJ]
-   [**Geopandas**](https://geopandas.org/)  [@kelsey_jordahl_2020_3946761] - √âtend les `DataFrame`s de [pandas](https://pandas.pydata.org/) [@pandas]

::::

::::{.columns}
:::{.column width="50%"}

![](./images/logo-pandas.svg){width=300}

:::

:::{.column width="50%"}

![](./images/logo_geopandas.svg){width=340}

:::
::::

## Le package *GeoPandas*

:::{.medium}

Un projet open source pour faciliter le travail avec des donn√©es g√©ospatiales vectorielles en Python. GeoPandas √©tend Pandas pour permettre de disposer d'un type de colonne g√©om√©trique et pour permettre d'effectuer des op√©rations spatiales. Les op√©rations g√©om√©triques sont r√©alis√©es avec `shapely`, les acc√®s en lecture / √©criture aux fichiers utilisent `fiona` et la visualisation utilise `matplotlib`.

![Format des GeoDataFrame](./images/geopandas-table.png)

:::

## Le package *GeoPandas* - Exemples

::: {.panel-tabset .custom-tab .small}

### Import et lecture

```{python gpd-tuto-import-1}
#| echo: false
import geodatasets

file_path = geodatasets.get_path("nybb")
```

Avec la fonction `read_file` :

```{python gpd-tuto-import-2}
#| echo: true
import geopandas as gpd

nybb = gpd.read_file(file_path)
```

### Affichage

Avec la m√©thode `plot` des `GeoDataFrame` :

```{python gpd-tuto-plot}
#| echo: true
nybb.plot()
```

### SCR

Affichage :

```{python gpd-tuto-crs}
#| echo: true
print(nybb.crs)
```

Transformation :

```{python gpd-tuto-transformation}
#| echo: true
nybb_geo = nybb.to_crs('EPSG:4326')
```

### Affichage avec fond de carte

En utilisant la biblioth√®que `contextily` :

```{python gpd-tuto-contextily}
#| echo: true
import contextily as cx

ax = nybb.to_crs('EPSG:3857').plot()
cx.add_basemap(ax, source='https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png')
ax.set_axis_off()
ax
```

### Centroide

Simplement en utilisant l'attribut `centroid` des `GeoDataFrame` :

```{python gpd-tuto-centroid}
#| echo: true
nybb.centroid.plot()
```

### Boundary

Simplement en utilisant l'attribut `boundary` des `GeoDataFrame` :

```{python gpd-tuto-boundary}
#| echo: true
nybb.boundary.plot()
```

### Zone tampon

En utilisant la m√©thode `buffer` des `GeoDataFrame` :

```{python gpd-tuto-buffer}
#| echo: true
buff_nybb = nybb.buffer(3000)
```

```{python gpd-tuto-buffer-2}
#| echo: true
ax = buff_nybb.plot(color="red")
nybb.plot(ax=ax, color="aliceblue")
```


### Aggr√©gation

En utilisant la m√©thode `dissolve` des `GeoDataFrame` :

```{python gpd-tuto-agg}
#| echo: true
# On peut utiliser dissolve(by="nom_colonne") si on veut aggr√©ger selon les valeurs d'une colonne
agg = nybb.dissolve()
agg.plot()
```


### Intersection

En utilisant la m√©thode `intersection` des `GeoDataFrame` :

```{python gpd-tuto-intersection}
#| echo: true
from shapely import wkt

point = wkt.loads('Point(998769.1146889535 174169.7607268664)')
intersecting = nybb.intersection(point.buffer(35000))
```

<br />

```{python gpd-tuto-intersectiob-2}
#| echo: true
ax = nybb.plot()
ax = intersecting.plot(ax=ax, color="red")
ax
```

:::


## Donn√©es raster

::::{.columns .medium}

:::{.column width="50%"}

[**Rasterio**](https://rasterio.readthedocs.io/) [@gillies_2019] :

:::{.small}

* lecture / √©criture de raster (*wrapper* de haut niveau autour de GDAL)
* donn√©es repr√©sent√©es sous forme d'`array` NumPy
* reprojection
* _resampling_
* _virtual files_
* etc.

:::

:::

:::{.column width="50%"}

[**Rasterstats**](https://pythonhosted.org/rasterstats/) :

:::{.small}

* r√©sumer des donn√©es raster sur la base de g√©om√©tries vectorielles
* extraction de valeurs √† un point pr√©cis

:::

[**xarray**](https://docs.xarray.dev/en/stable/) [@xarray] et [**rioxarray**](https://corteva.github.io/rioxarray/) [@rioxarray]:

:::{.small}

* *xarray* pour travailler avec des tableaux multidimensionnels √©tiquet√©s
* *rioxarray* pour ouvrir des jeux des donn√©es raster avec *rasterio*, les stocker dans le format de *xarray*, et avoir acc√®s √† diff√©rentes fonctionnalit√©s de *rasterio*
* moins "rustique" que d'utiliser rasterio seul / d√©pend de l'usage souhait√©

:::

:::
::::

## Le package *Rasterio*

:::{.small}

Exemple d'utilisation :

```{python example-rio-1}
#| echo: true
import rasterio as rio

with rio.open('./data/MODIS_ARRAY.nc') as f:
    # M√©tadonn√©es :
    metadata = f.meta
    # Lire toutes les bandes :
    data = f.read()
    # Ou f.read(1) pour lire seulement la premi√®re bande
```

- Un dictionnaire de m√©tadonn√©es + un tableau NumPy contenant la (ou les) bande(s) :

```{python example-rio-2}
#| echo: true
print(metadata)
print(data)
```

:::

## Les package *xarray* et *rioxarray*

Exemple d'utilisation :

::: {.panel-tabset .custom-tab .small}

### Import et lecture

```{python xarray-tuto-import-1}
#| echo: true
import rioxarray
import xarray

xds = xarray.open_dataarray("./data/MODIS_ARRAY.nc")
```

- Un objet de type `xarray.DataArray` ou `xarray.Dataset` qui contient les diff√©rentes m√©ta-donn√©es et les donn√©es :

```{python xarray-tuto-import-2}
xds
```

### Compl√©tion des valeurs manquantes

```{python xarray-tuto-na}
#| echo: true
filled = xds.rio.interpolate_na()
```

### Affichage

En utilisant la m√©thode `plot` des objets `xarray.DataArray` (ici apr√®s s√©lection d'un *subset* des donn√©es) :

```{python xarray-tuto-plot}
#| echo: true
import matplotlib.pyplot as plt

fig = plt.figure(figsize=(15, 5))
ax1, ax2 = (fig.add_subplot(131), fig.add_subplot(133))

xds.isel(x=slice(0, 20), y=slice(0, 20)).plot(ax=ax1)
filled.isel(x=slice(0, 20), y=slice(0, 20)).plot(ax=ax2)
```

### SCR

- Affichage :

```{python xarray-tuto-crs-1}
#| echo: true
xds.rio.crs
```

- Transformation :

```{python xarray-tuto-crs-2}
#| echo: true
xds = xds.rio.reproject("EPSG:6623")
```

### D√©coupage

- D√©coupage selon l'emprise des donn√©es contenues dans un `GeoDataFrame` (ici `gdf`) :

```{python xarray-tuto-clipping}
#| echo: true
#| eval: false
clipped = xds.rio.clip(gdf.geometry.values, gdf.crs, drop=False, invert=True)
```

:::


## Analyse spatiale

<img src="./images/logo-pysal.png" style="position: absolute; top: 5px; right: 20px; width: 120px; height: auto;"/>


:::{.medium}

√âcosyst√®me de biblioth√®ques pour l'analyse spatiale [PySAL](https://pysal.org/) <br />(Python Spatial Analysis Library, @pysal2007) :

:::

:::: {.columns .small}

::: {.column width="50%"}

**Explorer** :

- Analyse exploratoire des donn√©es spatiales (package [esda](https://pysal.org/esda/))
- Analyse de la dynamique des donn√©es spatiales longitudinales (package [giddy](https://pysal.org/giddy/))
- Mesure des in√©galit√©s dans l'espace et dans le temps (package [inequality](https://inequality.readthedocs.io/en/latest/))
- Analyse statistique de motifs ponctuels planaires (package [pointpats](https://pysal.org/pointpats/))
- Mesure de la s√©gr√©gation dans le temps et dans l'espace (package [segregation](https://pysal.org/segregation/))
- Morphom√©trie urbaine (package [momepy](https://docs.momepy.org/en/stable/))

:::

::: {.column width="50%"}

**Mod√©liser** :

- R√©gression g√©ographiquement pond√©r√©e √† plusieurs √©chelles (package [mgwr](https://mgwr.readthedocs.io/en/latest/))
- Mod√®les lin√©aires g√©n√©ralis√©s √©pars (package [spglm](https://spglm.readthedocs.io/en/latest/))
- Mod√®les d'interaction spatiale (package [spint](https://spint.readthedocs.io/en/latest/))
- Mod√®les de r√©gression spatiale (package [spreg](https://spreg.readthedocs.io/en/latest/))
- Mod√®les de composantes de variance √† corr√©lation spatiale √† plusieurs niveaux (package [spvcm](https://github.com/pysal/spvcm))
- *Areal interpolation* et cartographie dasym√©trique (package [tobler](https://pysal.org/tobler/))
- Accessibilit√© spatiale (package [access](https://pysal.org/access/))
- Optimisation spatiale (package [spopt](https://pysal.org/spopt/))

:::

::::


## Autres packages utiles ...

::::{.columns .medium}
:::{.column width="50%"}

- Binding Python pour [GRASS](https://grass.osgeo.org/grass82/manuals/libpython/index.html) + Int√©gration dans les notebooks Jupyter

![Source: <https://grass.osgeo.org/news/2022_06_05_results_student_grant_caitlin/>](./images/grass_jupyter_combo_vis.png)

:::

:::{.column width="50%"}

- [Iris](https://scitools-iris.readthedocs.io/en/stable/) - Analyse et visualisation de donn√©es des sciences de la Terre.

- Pour la cartographie : [cartopy](https://scitools.org.uk/cartopy/docs/latest/) ; [geoviews](https://geoviews.org/) et [geoplot](https://residentmario.github.io/geoplot/) bas√©s sur *cartopy* ; [PyGMT](https://www.pygmt.org/latest/) (selon les usages - pas de solution aussi aboutie que `mapsf` pour les cartes r√©alis√©es en SHS).

![](./images/cartopy.png)

- Un √©cosyst√®me riche pour le g√©ospatial (voir par exemple ici : [https://github.com/sacridini/Awesome-Geospatial#python](https://github.com/sacridini/Awesome-Geospatial#python)) et la visualisation de donn√©es (voir par exemple les outils list√©s par la plateforme [PyViz](https://pyviz.org/tools.html)).

:::
::::

## Ressources pour l'apprentissage de Python

:::{.medium}

- [Le tutoriel de la documentation officielle](https://docs.python.org/fr/3/tutorial/)

- [Le MOOC "Python : des fondamentaux aux concepts avanc√©s du langage" de l'Universit√© C√¥te d'Azur (6 semaines + semaines optionnelles, dont une semaine "√©cosyst√®me data-science")](https://www.fun-mooc.fr/fr/cours/python-3-des-fondamentaux-aux-concepts-avances-du-langage/)
  (selon vos centres d'int√©r√™t, d'autres MOOC comme ["Recherche reproductible : principes m√©thodologiques pour une science transparente"](https://www.fun-mooc.fr/fr/cours/recherche-reproductible-principes-methodologiques-pour-une-science-transparente/) de l'INRIA
  font appel √† Python ainsi qu'√† des comp√©tences transverses comme l'utilisation de Git, du Markdown, etc.)

- [Openclassrooms - Apprenez les bases du langage Python](https://openclassrooms.com/fr/courses/7168871-apprenez-les-bases-du-langage-python) 

- [Cours "Geo-Python" (en anglais - pr√©sente les bases de la programmation en Python pour l'analyse de donn√©es, avec une coloration g√©ospatiale et sans n√©cessiter de connaissances pr√©alables)](https://geo-python-site.readthedocs.io/en/latest/)

- [Cours "Introduction √† la programmation Python pour la biologie" (en fran√ßais)](https://python.sdv.univ-paris-diderot.fr/)

:::

:::{.notes}

Introduction √† la programmation Python pour la biologie : https://python.sdv.univ-paris-diderot.fr/

:::

## Ressources Python G√©ospatial

<br />

:::{.small}

Les ressources qui suivent supposent pour la plupart une connaissance de base du langage Python (boucles, conditions, fonctions, types de base, etc.).
Elles mobilisent les biblioth√®ques Python le plus souvent utilis√©es pour l'analyse de donn√©es et le traitement de donn√©es g√©ospatiales (*pandas*, *geopandas*, *rasterio*, *scipy*, etc.).

:::

<br />

:::{.medium}

- [Livre gratuit "Geocomputation with Python" (en anglais)](https://py.geocompx.org/) [@Dorman2022]

- [Cours "Automating GIS processes" (en anglais)](https://autogis-site.readthedocs.io/en/latest/)

- [Cours "Use Data for Earth and Environmental Science in Open Source Python" (en anglais)](https://www.earthdatascience.org/courses/use-data-open-source-python/)

- [Livre gratuit "Geographic Data Science with Python"](https://geographicdata.science/book/intro.html)

:::

# Partie 2 - Mise en pratique / Exercices

## Utiliser Python depuis VSCodium

<br>

:::{.medium}

- L'extension [Python](https://marketplace.visualstudio.com/items?itemName=ms-python.python) permet d'utiliser Python depuis VSCodium et l'extension [Jupyter](https://marketplace.visualstudio.com/items?itemName=ms-toolsai.jupyter) permet d'utiliser des notebooks Jupyter depuis VSCodium.

- Il est possible d'ouvrir un terminal depuis VSCodium en utilisant la commande <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>P</kbd> puis en tapant `Terminal: Create New Integrated Terminal`.

- Il est possible d'ex√©cuter un script Python depuis VSCodium en utilisant la commande <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>P</kbd> puis en tapant `Python: Run Python File in Terminal`.

- Il est possible d'ex√©cuter seulement une partie d'un script Python depuis VSCodium en s√©lectionnant le code √† ex√©cuter puis en utilisant la commande <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>P</kbd> puis en tapant `Python: Run Selection/Line in Python Terminal`.

:::

## Utiliser des notebooks Jupyter depuis VSCodium

<br>

:::{.medium}


- Ouvrir un notebook Jupyter depuis VSCodium : <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>P</kbd> puis en tapant `Jupyter: Create New Blank Notebook`.

- Ex√©cuter une cellule de code dans un notebook Jupyter : <kbd>Ctrl</kbd> + <kbd>Enter</kbd>.

- Ex√©cuter une cellule de code dans un notebook Jupyter et passer √† la cellule suivante : <kbd>Shift</kbd> + <kbd>Enter</kbd>.

- Ex√©cuter une cellule de code dans un notebook Jupyter et cr√©er une nouvelle cellule en dessous : <kbd>Alt</kbd> + <kbd>Enter</kbd>.

:::

## Utiliser Python depuis Spyder

:::{.medium}

- L'IDE [Spyder](https://www.spyder-ide.org/) permet d'utiliser Python depuis un environnement de d√©veloppement d√©di√© √† la science des donn√©es.

- Cet IDE a √©t√© install√© avec la distribution Anaconda, sur Windows, vous pouvez le lancer depuis le menu D√©marrer.

:::

## Exercice 1 - Modifier un fichier texte existant

::::{.columns .small}

:::{.column width="70%"}

**Objectif** : Cr√©ez un programme en Python qui permet de modifier un fichier texte existant.

**Instructions** :

1) Cr√©ez un fichier texte nomm√© `cities.csv` contenant le texte pr√©sent dans l'encart situ√© √† droite.

2) Cr√©ez un programme Python qui permet de modifier l'ent√™te du fichier `cities.csv` en rempla√ßant les valeurs `coord1` et `coord2` par `latitude` et `longitude`.
   Nous traitons ici ce fichier comme un fichier texte, il n'est donc pas n√©cessaire d'utiliser la biblioth√®que `csv`.
   Le nouveau contenu doit √™tre √©crit dans un nouveau fichier nomm√© `cities-new.csv`.

3) Ex√©cutez le programme et v√©rifiez que le fichier `cities-new.csv` a bien √©t√© cr√©√© et qu'il contient le nouveau contenu.

:::

:::{.column width="30%"}

**Contenu du fichier `data.csv`** :

<textarea style="width: 100%; font-size: 0.8em;" rows="5">
nom,coord1,coord2,value
Paris,48.8566,2.3522,10
Lyon,45.7640,4.8357,20
Marseille,43.2964,5.3700,30
Grenoble,45.1885,5.7245,40
</textarea>

:::

::::

## Exercice 2 - Conversion de Temp√©rature

::::{.columns .small}

:::{.column width="67%"}
**Objectif** : Cr√©ez un programme en Python qui permet de convertir la temp√©rature de Celsius en Fahrenheit et vice versa.

**Instructions** :

- 1) Demandez √† l'utilisateur de choisir le type de conversion qu'il souhaite effectuer : de Celsius √† Fahrenheit ou de Fahrenheit √† Celsius.

- 2) En fonction du choix de l'utilisateur, demandez-lui d'entrer la temp√©rature √† convertir.

- 3) Impl√©mentez les formules de conversion appropri√©es :

    - De Celsius √† Fahrenheit : $F = \frac{9}{5} \times C + 32$
    - De Fahrenheit √† Celsius : $C = \frac{5}{9} \times (F - 32)$

- 4) Affichez le r√©sultat de la conversion.

**R√©cup√©ration d'une valeur entr√©e par l'utilisateur** :

```python
choice = int(input('Entrez votre choix (1 ou 2) : '))
```
:::

:::{.column width="33%"}

**Exemple d'ex√©cution** :

```
Choisissez le type de conversion :
1. De Celsius √† Fahrenheit
2. De Fahrenheit √† Celsius

Entrez votre choix (1 ou 2) : 1

Entrez la temp√©rature en Celsius : 25

R√©sultat : 77.0¬∞F
```

:::
::::

## Exercice 3 - Lister les couches d'un flux WMS ou WFS

:::{.medium}

Dans cet exercice, vous utiliserez un notebook Jupyter existant et contenant d√©j√† des instructions Python pour lister les couches d'un flux WMS ou WFS et les sauvegarder dans un fichier CSV.

L'utilisation d'un notebook Jupyter permet de tester facilement des instructions Python et de les ex√©cuter pas √† pas.

<br />

Instructions :

- **R√©cup√©rez le notebook Jupyter [`ogc-web-services.ipynb`](notebooks/ogc-web-services.ipynb) et ouvrez-le dans VSCodium.**

:::

# Partie 3 - Python et QGIS

## Pourquoi Python-QGIS ?

- Lancer des commandes dans la console Python de QGIS

- Cr√©er et utiliser des extensions

- Ex√©cuter automatiquement un programme Python quand QGIS d√©marre

- Cr√©er des algorithmes de traitement

- Cr√©er des fonctions pour des expressions dans QGIS

- Cr√©er des applications personnalis√©es bas√©es sur l‚ÄôAPI QGIS

## L'interface de programmation PyQGIS

:::{.medium}

L'interface de programmation PyQGIS permet d'acc√©der √† la majorit√© des fonctionnalit√©s de QGIS depuis Python. Elle est g√©n√©r√©e automatiquement √† partir du code C++ de QGIS
et comporte plus de 2000 classes d√©crivant les diff√©rents aspects de l'application (`QgsProject`, `QgsProcessingAlgorithm`, `QgsDialog`, etc.),
des donn√©es qui y figurent (`QgsVectorLayer`, `QgsRasterLayer`, `QgsFeature`, `QgsGeometry`, etc.) et des fonctionnalit√©s disponibles (`QgsVectorFileWriter`, etc.).

Il est donc n√©cessaire de consulter la [documentation](https://qgis.org/pyqgis/master/) pour connaitre les m√©thodes et les attributs disponibles pour chaque classe.

:::

## √âtendre les expressions QGIS avec Python

:::{.medium}

Dans QGIS, les *expressions* peuvent √™tre utilis√©es dans diff√©rents m√©canismes de base :
s√©lection par expression, calcul des valeurs d'un champ (calculatrice de champ), r√®gles de style, √©tiquettes, etc.

QGIS prend √©galement en charge les expressions d√©finies par l'utilisateur. Gr√¢ce √† Python, vous pouvez d√©finir vos propres fonctions qui peuvent √™tre utilis√©es dans le moteur d'expression.

:::

## √âtendre les expressions QGIS avec Python

![](./images/expression-custom-function.png){.bordered}

## √âtendre les expressions QGIS avec Python

![](./images/expression-selection.png){.bordered}

## √âtendre les expressions QGIS avec Python

![](./images/expression-new-field.png){.bordered}

## Console Python dans QGIS

:::{.medium}

QGIS fournit une console interactive Python.

Elle peut √™tre ouverte de plusieurs mani√®res : 

- depuis le menu `Extensions > Console Python`
- en utilisant le raccourci clavier <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>P</kbd>`
- en utilisant le bouton <img src="./images/python-console.png" style="display: inline-block; width: 0.8em; height: auto;"/> dans la barre d'outils

Lors de l'utilisation de la console Python dans QGIS, une variable `iface` est d√©j√† existante. Cette variable est une instance de la classe `QgisInterface` et permet d'acc√©der √† la majorit√© des fonctions de QGIS (acc√®s au canevas de la carte, aux couches, aux menus, barres d'outils, etc. etc.).

**Cr√©ez un nouveau projet QGIS, ajoutez les [donn√©es d'exemples]() et ouvrez la console Python.**

:::

## Ex√©cuter des commandes dans la console Python

:::{.medium}

**Testez les commandes suivantes dans la console Python :**

**Exemple 1** : Afficher le nom des couches vecteur ou raster charg√©es dans QGIS et le nombre d'entit√©s pour les couches vecteur

```python
for layer in iface.mapCanvas().layers():
    if layer.type() == QgsMapLayer.VectorLayer:
        print(f"Vecteur : {layer.name()} ({layer.featureCount()} entit√©s) - {layer.crs().authid()}")
    elif layer.type() == QgsMapLayer.RasterLayer:
        print(f"Raster : {layer.name()} - {layer.crs().authid()}")
```

**Exemple 2** : Acc√©der √† la projection du projet

```python
print(iface.mapCanvas().mapSettings().destinationCrs().authid())
```

:::

## Ex√©cuter des commandes dans la console Python

:::{.medium}

**Exemple 3** : Obtenir une r√©f√©rence vers une couche vecteur √† partir de son nom et it√©rer sur ses entit√©s

```python
layer = QgsProject.instance().mapLayersByName('cities')[0]

# Une expression peut √™tre utilis√©e pour filtrer les entit√©s
expression = "$id < 5"

# On peut utiliser la m√©thode getFeatures() de la couche pour obtenir un it√©rateur sur les entit√©s
# si on ne lui donne pas d'argument, on obtient toutes les entit√©s de la couche
# si on lui donne une expression, on obtient seulement les entit√©s qui v√©rifient l'expression
for feature in layer.getFeatures(expression):
    # Ici 'feature' est donc un objet de type QgsFeature
    # Nous pouvons consulter la documentation pour connaitre les m√©thodes et les attributs disponibles
    print(feature['name'])
    # On peut aussi acc√©der √† la g√©om√©trie de l'entit√©
    geom = feature.geometry()
    print(geom.asWkt())
```

:::

## Ex√©cuter des commandes dans la console Python

:::{.small}

**Exemple 4** : Cr√©er une couche vecteur √† partir d'une couche existante et l'ajouter au projet

```python
import random

layer = QgsProject.instance().mapLayersByName('cities')[0]

# On cr√©e une couche m√©moire vide
mem_layer = QgsVectorLayer('Polygon?crs=EPSG:4326', 'cities-buffer', 'memory')
pr = mem_layer.dataProvider()

# Sp√©cification de deux champs
pr.addAttributes([
    QgsField("Buffer_value", QVariant.Double),
])
mem_layer.updateFields()

for feature in layer.getFeatures():
    ft = QgsFeature()
    # On calcule le buffer
    geom = QgsGeometry(feature.geometry())
    # On converti la g√©om√©trie dans un syst√®me de coordonn√©es permettant de calculer des distances
    geom.transform(QgsCoordinateTransform(layer.crs(), QgsCoordinateReferenceSystem("ESRI:53030"), QgsProject.instance()))
    buffer_value = random.randint(10000, 200000)
    buffer = geom.buffer(buffer_value, 5)
    # On remet la g√©om√©trie dans le syst√®me de coordonn√©es de la couche
    buffer.transform(QgsCoordinateTransform(QgsCoordinateReferenceSystem("ESRI:53030"), layer.crs(), QgsProject.instance()))
    # On ajoute la g√©om√©trie √† l'entit√©
    ft.setGeometry(buffer)
    ft.setAttributes([buffer_value])
    # On ajoute l'entit√© √† la couche m√©moire
    pr.addFeatures([ft])

mem_layer.updateExtents()
    
# On ajoute la couche m√©moire au projet
QgsProject.instance().addMapLayer(mem_layer)
```

:::

## Utiliser les algorithmes de traitement existants

:::{.medium}

QGIS fournit un ensemble d'algorithmes de traitement qui peuvent √™tre utilis√©s dans la console Python, en utilisant le module Python `processing`.

```python
# On peut lister les algorithmes disponibles
for alg in QgsApplication.processingRegistry().algorithms():
    print("{}:{} --> {}".format(
        alg.provider().name(), alg.name(), alg.displayName()))
```

Il est possible de consulter la documentation de chaque algorithme en utilisant la m√©thode `help()`.

```python
processing.algorithmHelp("qgis:voronoipolygons")
```

Ou de consulter la documentation en ligne : [https://docs.qgis.org/latest/en/docs/user_manual/processing_algs/qgis/vectorgeometry.html#voronoi-polygons](https://docs.qgis.org/latest/en/docs/user_manual/processing_algs/qgis/vectorgeometry.html#voronoi-polygons)

C'est gr√¢ce √† ces informations que vous aurez connaissance des param√®tres n√©cessaires pour utiliser un algorithme.

*Notez que les param√®tres sont les m√™mes que ceux utilis√©s dans l'interface graphique (et qui peuvent √™tre consult√©s dans la boite de dialogue de l'algorithme).*

:::

## Utiliser les algorithmes de traitement existants

:::{.medium}

```python
import processing

# Pour utiliser un algorithme, il faut connaitre son nom complet
# G√©n√©ralement, deux arguments sont n√©cessaires : son nom et les param√®tres
result = processing.run("qgis:voronoipolygons", {
    'INPUT': 'cities',
    'BUFFER': 0,
    'OUTPUT': 'TEMPORARY_OUTPUT'
})

# On peut ensuite ajouter le r√©sultat au projet
# (l'objet retourn√© par la m√©thode run() est un dictionnaire,
# on peut donc acc√©der √† la couche r√©sultat avec la cl√© 'OUTPUT')
QgsProject.instance().addMapLayer(result['OUTPUT'])
```

:::

## Cr√©er des algorithmes de traitement

:::{.medium}

Il est possible de cr√©er des algorithmes de traitement personnalis√©s en utilisant le module Python `processing`.

:::

## R√©f√©rences sur l'API Python de QGIS

<br />

- [PyQGIS developer cookbook (documentation officielle)](https://docs.qgis.org/latest/en/docs/pyqgis_developer_cookbook/index.html)
- [PyQGIS API documentation (documentation officielle)](https://qgis.org/pyqgis/master/)

<br />

- [TP Python pour QGIS (TP de 12h donn√© en Licence Pro.)](https://mthh.github.io/TP_PythonQGIS/)
- [QGIS tutorials - Rubrique "Python Scripting (PyQGIS)"](https://www.qgistutorials.com/)


# Partie 4 - Mise en pratique / Exercices

## Exercice 1 - √âtendre les expressions QGIS avec Python

:::{.medium}

Dans cet exercice, vous cr√©erez une fonction Python qui permet de calculer la distance entre deux points (un point fixe et un point mobile).

Cette fonction sera utilis√©e depuis la calculatrice de champ afin de cr√©er un nouveau champ contenant la distance entre chaque point et un point fixe.

:::

## Exercice 2 - Manipuler des donn√©es vectorielles

:::{.medium}

Dans cet exercice, vous adapterez un script existant pour modifier une couche vectorielle.

:::

## Exercice 3 - Ajouter un algorithme de traitement

:::{.medium}

Dans cet exercice, vous cr√©erez un algorithme de traitement qui permet ...

:::

# Outro

## R√©f√©rences bibliographiques

<!-- R√©f√©rence will be added here automatically from 'references.bib' -->



